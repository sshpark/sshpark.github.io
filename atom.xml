<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sshpark</title>
  
  <subtitle>先定个小目标</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sshpark.com.cn/"/>
  <updated>2021-06-15T13:37:44.610Z</updated>
  <id>http://sshpark.com.cn/</id>
  
  <author>
    <name>Sshpark</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统：16位实模式转32位保护模式</title>
    <link href="http://sshpark.com.cn/2021/05/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A16%E4%BD%8D%E5%AE%9E%E6%A8%A1%E5%BC%8F%E8%BD%AC32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://sshpark.com.cn/2021/05/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A16%E4%BD%8D%E5%AE%9E%E6%A8%A1%E5%BC%8F%E8%BD%AC32%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-05-26T15:32:55.000Z</published>
    <updated>2021-06-15T13:37:44.610Z</updated>
    
    <content type="html"><![CDATA[<p>随着计算机硬件的不断发展，可用内存（RAM）也变得越来越大。此外，实模式下缺乏对内存的保护，这导致了由于非法内存访问而产生的一些未知错误。这些问题在保护模式下得到了一定的解决，其作用主要有以下两点：</p><ol><li>支持更大的内存空间寻址</li><li>区分系统程序和用户程序，对访问内存的地址加以限制，防止程序非法访问内存</li></ol><p>此外，我们的内存采用的是分段模型，要实现对内存的保护，就是要实现对段的保护。段的相关信息用一个称为<strong>段描述符</strong>的数据结构去维护，多个段描述符组成全局描述符表（GDT），它们都存放在<strong>内存</strong>中。</p><h3 id="全局描述符表-GDT"><a href="#全局描述符表-GDT" class="headerlink" title="全局描述符表 GDT"></a>全局描述符表 GDT</h3><p>将CPU从 16 位实模式切换到 32 位保护模式的最困难部分是，我们必须在内存中准备一个称为全局描述符表（GDT）的复杂数据结构，该结构定义了内存段信息及其保护模式下的额外信息。而 GDT 则是由多个段描述符组成，一个段描述符由 8 bytes 组成，其组成部分有：</p><ul><li>段基址，它定义了段在物理内存中的起始位置</li><li>段长度，定义了段的大小</li><li>标识位，段是否可读写，可执行等</li></ul><p>段描述符结构如下图所示：</p><p><img src="http://sshpark.github.io/images/images/2021-06-15.9.26.02.png" alt="2021-06-15.9.26.02"></p><h3 id="切换步骤"><a href="#切换步骤" class="headerlink" title="切换步骤"></a>切换步骤</h3><ol><li>准备段描述符信息</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">; GDT</span><br><span class="line"></span><br><span class="line">gdt_start:</span><br><span class="line"></span><br><span class="line">gdt_null:   ; 第一个段描述符强制设置为 0</span><br><span class="line">    dd 0x0</span><br><span class="line">    dd 0x0</span><br><span class="line"></span><br><span class="line">gdt_code:   ; the code segment descriptor</span><br><span class="line">    ; base &#x3D; 0x0, limit &#x3D; 0xfffff</span><br><span class="line">    ; 1st flags: (present)1 (privilege)00 (descriptor type)1 -&gt; 1001b</span><br><span class="line">    ; type flags: (code )1 ( conforming )0 (readable )1 (accessed )0 -&gt; 1010b</span><br><span class="line">    ; 2nd flags: ( granularity )1 (32- bit default )1 (64- bit seg )0 (AVL )0 -&gt; 1100b</span><br><span class="line">    dw 0xffff       ; Limit (bits 0-15)</span><br><span class="line">    dw 0x0          ; Base  (bits 0-15)</span><br><span class="line">    db 0x0          ; Base  (bits 16-23)</span><br><span class="line">    db 10011010b    ; 1st flags , type flags</span><br><span class="line">    db 11001111b    ; 2nd flags , Limit (bits 16 -19)</span><br><span class="line">    db 0x0          ; Base (bits 24-31)</span><br><span class="line"></span><br><span class="line">gdt_data:   ;the data segment descriptor</span><br><span class="line">    ; Same as code segment expect for the type flags:</span><br><span class="line">    ; types flags: (code) 0 (expand down) 0 (writable) 1 (accessed) 0 -&gt; 0010 b</span><br><span class="line">    dw 0xffff       ; Limit (bits 0 -15)</span><br><span class="line">    dw 0x0          ; Base  (bits 0-15)</span><br><span class="line">    db 0x0          ; Base  (bits 16-23)</span><br><span class="line">    db 10010010b    ; 1st flags , type flags</span><br><span class="line">    db 11001111b    ; 2nd flags , Limit (bits 16 -19)</span><br><span class="line">    db 0x0          ; Base (bits 24-31)</span><br><span class="line"></span><br><span class="line">gdt_end:    ; The reason for putting a label at the end of the </span><br><span class="line">            ; GDT is so we can have the assembler calculate </span><br><span class="line">            ; the size of the GDT for the GDT decriptor (below)</span><br><span class="line"></span><br><span class="line">; GDT descriptor</span><br><span class="line">gdt_descriptor:</span><br><span class="line">    dw gdt_end - gdt_start - 1    ; Size of GDT</span><br><span class="line">    dd gdt_start                  ; Start address of our GDT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; 设置保护模式下要用到的段地址，代码段和数据段</span><br><span class="line">CODE_SEG equ gdt_code - gdt_start</span><br><span class="line">DATA_SEG equ gdt_data - gdt_start</span><br></pre></td></tr></table></figure><ol><li>加载设置 GDTR 寄存器，使之指向全局段描述符表</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt [ gdt_descriptor ]</span><br></pre></td></tr></table></figure><ol><li>设置 CR0 寄存器，开启保护模式。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, cr0 ; 为了使开关进入保护模式，我们将 CR0 的第一位（控制寄存器）置 1</span><br><span class="line">or eax, 0x1</span><br><span class="line">mov cr0, eax</span><br></pre></td></tr></table></figure><ol><li>进行长跳转，加载 CS 段寄存器。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp CODE_SEG:init_pm</span><br></pre></td></tr></table></figure><p>进行长跳转的原因是因为我们无法直接或间接 mov 一个数据到 CS 寄存器中，因为刚刚开启保护模式时，CS 的影子寄存器还是实模式下的值，所以需要告诉 CPU 加载新的段信息。·</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着计算机硬件的不断发展，可用内存（RAM）也变得越来越大。此外，实模式下缺乏对内存的保护，这导致了由于非法内存访问而产生的一些未知错误。这些问题在保护模式下得到了一定的解决，其作用主要有以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持更大的内存空间寻址&lt;/li&gt;
&lt;li&gt;区分系
      
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://sshpark.com.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MAML: 模型无关的元学习</title>
    <link href="http://sshpark.com.cn/2020/08/26/MAML-%E6%A8%A1%E5%9E%8B%E6%97%A0%E5%85%B3%E7%9A%84%E5%85%83%E5%AD%A6%E4%B9%A0/"/>
    <id>http://sshpark.com.cn/2020/08/26/MAML-%E6%A8%A1%E5%9E%8B%E6%97%A0%E5%85%B3%E7%9A%84%E5%85%83%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-08-26T09:16:55.000Z</published>
    <updated>2021-05-25T11:21:28.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是元学习"><a href="#什么是元学习" class="headerlink" title="什么是元学习"></a>什么是元学习</h1><p>元学习是目前人工智能领域一个令人振奋的研究领域。大量的研究结果表明元学习已经在人工智能领域上取得了重大突破。在正式介绍元学习之前，先来看看传统的人工智能模型是如何工作的。</p><p>近几年来，深度学习迅速发展，出现了生成式对抗网络（GAN）和胶囊网络（capsule network）等优秀的算法。但深度神经网络存在的一个问题是，我们需要有一个很大的训练集来训练我们的模型，当我们只有很少的数据集时，它很大程度上会失败。再比如说，我们训练了一个深度学习模型来执行任务 A，现在，当我们有一个新的任务 B，并且与 A 密切相关，但是我们不能使用相同的模型。我们需要为任务 B 从头开始训练模型，因此对于每个任务，我们都需要从头开始训练模型，忽略了任务间的相关性。</p><p>事实上，人脑中的学习机制具备一种能力。在面对不同的任务时，人脑的学习机制并不相同。即使面对一个新的任务，人们往往也可以很快找到其学习方式。这种可以动态调整学习方式的能力，称为<strong>元学习</strong>。元学习产生了一个多功能的人工智能模型，它可以学习执行各种任务，而不需要从头开始训练它们。对于一个新的相关任务，它可以利用从以前的任务中获得的学习能力而不必从头开始训练它们。</p><h1 id="MAML-算法"><a href="#MAML-算法" class="headerlink" title="MAML 算法"></a>MAML 算法</h1><p>深度学习模型通过梯度的反向传播进行学习。然而，基于梯度的优化既不能应对少量的训练样本，也不能在少量的优化步骤内收敛。那么有没有一种方法可以调整优化算法，让模型在少量样本的情况下就能很好的学习？这就是基于优化方法（optimization-based）的元学习算法。</p><p>基于优化方法的元学习中，<a href="https://arxiv.org/abs/1703.03400" target="_blank" rel="noopener">MAML</a>可以说是当中最有名的了，它是一种相当通用的优化算法，可以与<strong>基于梯度更新</strong>的算法兼容。</p><p>其主要思想是：训练模型的初始化参数（initial parameter），使模型能在来自新任务的少量数据上对参数执行数次（1次或多次）的梯度更新后能得到最佳的表现。</p><h2 id="MAML-算法的流程"><a href="#MAML-算法的流程" class="headerlink" title="MAML 算法的流程"></a>MAML 算法的流程</h2><p>假设所有的任务都来 自于一个任务空间，其分布为 $p(\mathcal{T})$，我们可以在这个任务空间的所有任务上学习一种通用的表示，这种表示可以经过梯度下降方法在一个特定的单任务上进行精调（fine-tune）。假设一个模型为 $f(\theta)$，如果我们让这个模型适应到一个新任务 $\mathcal{T}(m)$上， 通过一步或多步的梯度下降更新，学习到的任务适配参数为</p><script type="math/tex; mode=display">\theta_{m}^{\prime}=\theta-\alpha \nabla_{\theta} \mathcal{L}_{\mathcal{T}_{m}}\left(f_{\theta}\right)</script><p>其中 $\alpha$ 为学习率。这里 $\theta_{m}^{\prime}$ 可以理解为关于 $\theta$ 的函数，而不是真正的参数更新。</p><p>MAML的目标是<strong>学习一个参数 $\theta$</strong> 使得其经过一个梯度迭代就可以在新任务上达到最好的性能。</p><script type="math/tex; mode=display">\min _{\theta} \sum_{\mathcal{T}_{m} \sim p(\mathcal{T})} \mathcal{L}_{\mathcal{T}_{m}}\left(f\left(\theta_{m}^{\prime}\right)\right)=\sum_{\mathcal{T}_{m} \sim p(\mathcal{T})} \mathcal{L}_{\mathcal{T}_{m}}\left(f\left({\theta}-\alpha \nabla_{\theta} \mathcal{L}_{\mathcal{T}_{m}}\left(f_{\theta}\right)\right)\right)</script><p>在所有任务上的元优化（Meta-Optimization）也采用梯度下降来进行优化，即</p><script type="math/tex; mode=display">\theta \leftarrow \theta-\beta \nabla_{\theta} \sum_{m=1}^{M} \mathcal{L}_{\mathcal{T}_{m}}\left(f_{\theta_{m}^{\prime}}\right)</script><p>其中 $\beta$ 为元学习率，这里为一个真正的参数更新步骤。这里需要计算关于 $\theta$ 的二阶梯度，但用一级近似通常也可以达到比较好的性能。</p><p>算法描述如下：</p><p><img src="http://sshpark.github.io/images/20200826235916.png" style="zoom:50%;" /></p><p>算法步骤：</p><ol><li><p>随机初始化参数 $\theta$</p></li><li><p>从任务分布空间 $p(\mathcal{T})$ 选取若干个任务</p><p>在监督学习任务中，任务定义为  <script type="math/tex">\mathscr{T}_{i} \triangleq\left\{p_{i}(\mathbf{x}), p_{i}(\mathbf{y} \mid \mathbf{x}), \mathscr{L}_{i}\right\}</script><br>其中<script type="math/tex">p_{i}(\mathbf{x}), p_{i}(\mathbf{y} \mid \mathbf{x})</script>对应了真实的数据生成分布（通常无法得到，但是能够在训练的过程中反映出来），$\mathscr{L}_{i}$ 表示的是损失函数。不同任务的区别可能是这三个中的某个或者多个不同。</p></li><li><p>更新任务 <script type="math/tex">\mathcal{T}_{i}</script> 的参数得到 <script type="math/tex">\theta_{i}^{\prime}</script></p></li><li><p>根据内循环得到的 $\theta_{i}^{\prime}$ 在其任务$\mathcal{T}_i$  上对应的测试集上计算损失（loss），并对初始化参数 $\theta$ 进行梯度更新</p></li></ol><p>算法过程如下图所示：</p><p><img src="http://sshpark.github.io/images/20200903143037.png" style="zoom:50%;" /></p><p>$\theta$ 是初始化参数，也就是元学习的目标，通过不同任务的更新方向去更新 $\theta$，使得 $\theta$ 达到一个敏感（sensitive）位置，也就是说任务在这个位置只需要做一步或者几步的梯度下降就会引起损失函数的较大变化，迅速达到该任务的“最优”位置。</p><h2 id="MAML-的简单例子"><a href="#MAML-的简单例子" class="headerlink" title="MAML 的简单例子"></a>MAML 的简单例子</h2><p>为了理解 MAML 算法是如何寻找一个更好且鲁棒的初始化参数 $\theta$ 去泛化这些任务的。我们从头实现一个 MAML 算法。</p><p>为了方便理解，这里我们考虑一个二分类任务，随机生成一些训练数据，并用一个单层的神经网络去做训练。</p><h3 id="生成训练数据"><a href="#生成训练数据" class="headerlink" title="生成训练数据"></a>生成训练数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_points</span><span class="params">(k)</span>:</span></span><br><span class="line">  x = np.random.rand(k, <span class="number">50</span>)</span><br><span class="line">  y = np.random.choice([<span class="number">0</span>, <span class="number">1</span>], size=k, p = [<span class="number">.5</span>, <span class="number">.5</span>]).reshape([<span class="number">-1</span>, <span class="number">1</span>])</span><br><span class="line">  <span class="keyword">return</span> x, y</span><br></pre></td></tr></table></figure><p>测试一下函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = sample_points(<span class="number">10</span>)</span><br><span class="line">print(x[<span class="number">0</span>])</span><br><span class="line">print(y[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[0.42100647 0.69403514 0.67855943 0.57774404 0.15666203 0.91099776</span><br><span class="line"> 0.01246907 0.08118128 0.07718763 0.57900541 0.35844089 0.03127173</span><br><span class="line"> 0.5760209  0.71506323 0.94122599 0.95702823 0.35303246 0.35338326</span><br><span class="line"> 0.35029937 0.62252008 0.66232719 0.11546544 0.69487415 0.36424861</span><br><span class="line"> 0.46909378 0.12574337 0.82647021 0.40940772 0.99659183 0.27186814</span><br><span class="line"> 0.56939123 0.02092227 0.01067603 0.9077246  0.85177498 0.5933496</span><br><span class="line"> 0.48722737 0.66599244 0.01389198 0.9820469  0.11796959 0.94809311</span><br><span class="line"> 0.8243121  0.27004836 0.30353558 0.87978769 0.59162869 0.07974159</span><br><span class="line"> 0.27372265 0.41991061]</span><br><span class="line">[0]</span><br></pre></td></tr></table></figure><h3 id="单层神经网络"><a href="#单层神经网络" class="headerlink" title="单层神经网络"></a>单层神经网络</h3><p>为了简单以及方便理解，我们使用只有单层的神经网络来预测输出。如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = np.matmul(X, theta)</span><br><span class="line">YHat = sigmoid(a)</span><br></pre></td></tr></table></figure><p>所以，我们使用MAML来寻找这个最优的参数值theta，这个参数值是可以在各个任务中通用的。这样对于一个新的任务，我们只进行几次梯度下降，在较少的时间内从几个数据点中学习。</p><h3 id="MAML-实现"><a href="#MAML-实现" class="headerlink" title="MAML 实现"></a>MAML 实现</h3><p>现在，我们定义一个名为MAML的类，在这个类中我们实现了MAML算法。在 <strong>init</strong> 方法中，我们将初始化所有必要的变量。然后我们定义我们的 <code>sigmoid</code> 激活函数。接下来我们定义我们的训练函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MAML</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化任务数</span></span><br><span class="line">    self.num_tasks = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化每个任务的样本数</span></span><br><span class="line">    self.num_samples = <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 算法迭代次数</span></span><br><span class="line">    self.epochs = <span class="number">10000</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 内循环的学习率</span></span><br><span class="line">    self.alpha = <span class="number">0.0001</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 外循环的学习率</span></span><br><span class="line">    self.beta = <span class="number">0.0001</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 随机初始化初始参数</span></span><br><span class="line">    self.theta = np.random.normal(size=<span class="number">50</span>).reshape(<span class="number">50</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(self, a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / (<span class="number">1</span> + np.exp(-a) )</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> range(self.epochs):</span><br><span class="line">      self.theta_ = []</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_tasks):</span><br><span class="line">        XTrain, YTrain = sample_points(self.num_samples)</span><br><span class="line">  </span><br><span class="line">        a = np.matmul(XTrain, self.theta)</span><br><span class="line">        </span><br><span class="line">        YHat = self.sigmoid(a)</span><br><span class="line">        <span class="comment"># 交叉熵损失函数</span></span><br><span class="line">        loss = ((np.matmul(-YTrain.T, np.log(YHat)) - np.matmul((<span class="number">1</span>-YTrain.T), np.log(<span class="number">1</span>-YHat))) / self.num_samples)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 梯度下降</span></span><br><span class="line">        gradient = np.matmul(XTrain.T, (YHat - YTrain)) / self.num_samples</span><br><span class="line">        self.theta_.append(self.theta - self.alpha*gradient)</span><br><span class="line">      <span class="comment"># 初始化 meta 梯度</span></span><br><span class="line">      meta_gradient = np.zeros(self.theta.shape)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_tasks):</span><br><span class="line">        <span class="comment"># 任务的测试集</span></span><br><span class="line">        XTest, YTest = sample_points(<span class="number">10</span>)</span><br><span class="line">        a = np.matmul(XTest, self.theta_[i])</span><br><span class="line">        YPred = self.sigmoid(a)</span><br><span class="line">        </span><br><span class="line">        meta_gradient += np.matmul(XTest.T, (YPred - YTest)) / self.num_samples</span><br><span class="line"><span class="comment"># 更新外循环的原参数 \theta      </span></span><br><span class="line">      self.theta = self.theta-self.beta*meta_gradient/self.num_tasks</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> e%<span class="number">1000</span>==<span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"Epoch &#123;&#125;: Loss &#123;&#125;\n"</span>.format(e,loss))</span><br><span class="line">        print(<span class="string">'Updated Model Parameter Theta\n'</span>)</span><br><span class="line">        print(<span class="string">'Sampling Next Batch of Tasks \n'</span>)</span><br><span class="line">        print(<span class="string">'---------------------------------\n'</span>)</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = MAML()</span><br><span class="line">model.train()</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Epoch 0: Loss 1.144232040593275</span><br><span class="line"></span><br><span class="line">Updated Model Parameter Theta</span><br><span class="line"></span><br><span class="line">Sampling Next Batch of Tasks </span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">Epoch 1000: Loss 0.6450955930326157</span><br><span class="line"></span><br><span class="line">Updated Model Parameter Theta</span><br><span class="line"></span><br><span class="line">Sampling Next Batch of Tasks </span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">Epoch 2000: Loss 0.646503969137526</span><br><span class="line"></span><br><span class="line">Updated Model Parameter Theta</span><br><span class="line"></span><br><span class="line">Sampling Next Batch of Tasks </span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">Epoch 3000: Loss 1.3089942317460603</span><br><span class="line"></span><br><span class="line">Updated Model Parameter Theta</span><br><span class="line"></span><br><span class="line">Sampling Next Batch of Tasks </span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">Epoch 4000: Loss 0.551582623398733</span><br><span class="line"></span><br><span class="line">Updated Model Parameter Theta</span><br><span class="line"></span><br><span class="line">Sampling Next Batch of Tasks </span><br><span class="line"></span><br><span class="line">---------------------------------</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="MAML-算法的缺点"><a href="#MAML-算法的缺点" class="headerlink" title="MAML 算法的缺点"></a>MAML 算法的缺点</h1><p><a href="https://arxiv.org/abs/1810.09502" target="_blank" rel="noopener">How to train your MAML</a> 指出了 maml 存在的 5 个问题并给出了改进建议，以下是 maml 存在的 5 个问题</p><ol><li>Training Instabilit</li><li>Second Order Derivative Cost</li><li>Absence of Batch Normalization Statistic Accumulation</li><li>Shared (across step) Batch Normalization Bias</li><li>Shared Inner Loop (across step and across parameter) Learning Rate</li></ol>]]></content>
    
    <summary type="html">
    
      元学习是目前人工智能领域一个令人振奋的研究领域。大量的研究结果表明元学习已经在人工智能领域上取得了重大突破。基于优化方法的元学习中，MAML可以说是当中最有名的了，它是一种相当通用的优化算法，可以与基于梯度更新的算法兼容。
    
    </summary>
    
    
    
      <category term="元学习" scheme="http://sshpark.com.cn/tags/%E5%85%83%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>学堂云 3.0 刷课代码</title>
    <link href="http://sshpark.com.cn/2020/04/30/%E5%AD%A6%E5%A0%82%E4%BA%91-3-0-%E5%88%B7%E8%AF%BE%E4%BB%A3%E7%A0%81/"/>
    <id>http://sshpark.com.cn/2020/04/30/%E5%AD%A6%E5%A0%82%E4%BA%91-3-0-%E5%88%B7%E8%AF%BE%E4%BB%A3%E7%A0%81/</id>
    <published>2020-04-30T10:13:51.000Z</published>
    <updated>2021-05-25T11:21:28.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在学堂云刷课的时候，不能离开这个页面，否则的话视频会暂停。</p><h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>在当前页面调试，并将下面的 <code>js</code> 代码输入带控制台中执行，然后就可以离开页面播放了，同时也可以开<strong>多个页面</strong>刷视频。</p><p>代码写的很烂（边查边写），能用就好。。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">document</span>.getElementById(<span class="string">'video'</span>).play()&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;在学堂云刷课的时候，不能离开这个页面，否则的话视频会暂停。&lt;/p&gt;
&lt;h1 id=&quot;解决方式&quot;&gt;&lt;a href=&quot;#解决方式&quot; class=
      
    
    </summary>
    
    
    
      <category term="工具" scheme="http://sshpark.com.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配算法-Horspool,Boyer-Moore,Sunday</title>
    <link href="http://sshpark.com.cn/2020/04/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-Horspool-Boyer-Moore-Sunday/"/>
    <id>http://sshpark.com.cn/2020/04/22/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95-Horspool-Boyer-Moore-Sunday/</id>
    <published>2020-04-22T08:54:32.000Z</published>
    <updated>2021-05-26T15:40:45.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Horspool-算法"><a href="#Horspool-算法" class="headerlink" title="Horspool 算法"></a>Horspool 算法</h1><p><strong>Boyer-Moore</strong> 算法的简化版本。每次从模式串末尾开始匹配，匹配失败的话根据转移表确定下一次匹配开始的位置。具体介绍可以看看 <a href="https://blog.csdn.net/khwkhwkhw/article/details/51288502" target="_blank" rel="noopener">Horspool(字符串匹配)算法</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Horspool</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">const</span> <span class="keyword">char</span>* pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n = <span class="built_in">strlen</span>(src);</span><br><span class="line">    <span class="keyword">size_t</span> m = <span class="built_in">strlen</span>(pattern);</span><br><span class="line">    <span class="keyword">size_t</span> table[m];</span><br><span class="line">    <span class="comment">// 预处理转移表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) table[i] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; i++)</span><br><span class="line">        table[pattern[i]-<span class="string">'a'</span>] = m<span class="number">-1</span>-i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> i = m<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= m<span class="number">-1</span> &amp;&amp; pattern[m<span class="number">-1</span>-k] == src[i-k]) k++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == m) <span class="keyword">return</span> i-m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> i += table[src[i]-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Boyer-Moore-算法"><a href="#Boyer-Moore-算法" class="headerlink" title="Boyer-Moore 算法"></a>Boyer-Moore 算法</h1><p>该算法常用于文本编辑器中的搜索匹配功能，相关<strong>介绍以及实现</strong>来自这篇博客 <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/7637875.html" target="_blank" rel="noopener">从入门到精通之Boyer-Moore字符串搜索算法详解</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CHAR 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) (x) &gt; (y) ? (x) : (y)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BoyerMoore</span><span class="params">(<span class="keyword">char</span> *pattern, <span class="keyword">int</span> m, <span class="keyword">char</span> *<span class="built_in">text</span>, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">text</span>[<span class="number">256</span>], pattern[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, <span class="built_in">text</span>, pattern);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">text</span> == <span class="number">0</span> || pattern == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        BoyerMoore(pattern, <span class="built_in">strlen</span>(pattern), <span class="built_in">text</span>, <span class="built_in">strlen</span>(<span class="built_in">text</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">char</span> *arrayName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: "</span>, arrayName);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, <span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreBmBc</span><span class="params">(<span class="keyword">char</span> *pattern, <span class="keyword">int</span> m, <span class="keyword">int</span> bmBc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MAX_CHAR; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bmBc[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bmBc[pattern[i]] = m - <span class="number">1</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  printf("bmBc[]: ");</span></span><br><span class="line"><span class="comment">    for(i = 0; i &lt; m; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        printf("%d ", bmBc[pattern[i]]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    printf("\n"); */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffix_old</span><span class="params">(<span class="keyword">char</span> *pattern, <span class="keyword">int</span> m, <span class="keyword">int</span> suff[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    suff[m - <span class="number">1</span>] = m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; pattern[j] == pattern[m - <span class="number">1</span> - i + j]) j--;</span><br><span class="line"></span><br><span class="line">        suff[i] = i - j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffix</span><span class="params">(<span class="keyword">char</span> *pattern, <span class="keyword">int</span> m, <span class="keyword">int</span> suff[])</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> f, g, i;</span><br><span class="line"></span><br><span class="line">   suff[m - <span class="number">1</span>] = m;</span><br><span class="line">   g = m - <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (i = m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt; g &amp;&amp; suff[i + m - <span class="number">1</span> - f] &lt; i - g)</span><br><span class="line">         suff[i] = suff[i + m - <span class="number">1</span> - f];</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (i &lt; g)</span><br><span class="line">            g = i;</span><br><span class="line">         f = i;</span><br><span class="line">         <span class="keyword">while</span> (g &gt;= <span class="number">0</span> &amp;&amp; pattern[g] == pattern[g + m - <span class="number">1</span> - f])</span><br><span class="line">            --g;</span><br><span class="line">         suff[i] = f - g;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   print(suff, m, "suff[]");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreBmGs</span><span class="params">(<span class="keyword">char</span> *pattern, <span class="keyword">int</span> m, <span class="keyword">int</span> bmGs[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> suff[SIZE];  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算后缀数组</span></span><br><span class="line">    suffix(pattern, m, suff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先全部赋值为m，包含Case3</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bmGs[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Case2</span></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(suff[i] == i + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; m - <span class="number">1</span> - i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(bmGs[j] == m)</span><br><span class="line">                    bmGs[j] = m - <span class="number">1</span> - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Case1</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= m - <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bmGs[m - <span class="number">1</span> - suff[i]] = m - <span class="number">1</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  print(bmGs, m, "bmGs[]");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BoyerMoore</span><span class="params">(<span class="keyword">char</span> *pattern, <span class="keyword">int</span> m, <span class="keyword">char</span> *<span class="built_in">text</span>, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, bmBc[MAX_CHAR], bmGs[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Preprocessing</span></span><br><span class="line">    PreBmBc(pattern, m, bmBc);</span><br><span class="line">    PreBmGs(pattern, m, bmGs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Searching</span></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= n - m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; pattern[i] == <span class="built_in">text</span>[i + j]; i--);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Find it, the position is %d\n"</span>, j);</span><br><span class="line">            j += bmGs[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j += MAX(bmBc[<span class="built_in">text</span>[i + j]] - m + <span class="number">1</span> + i, bmGs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No find.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Sunday-算法"><a href="#Sunday-算法" class="headerlink" title="Sunday 算法"></a>Sunday 算法</h1><p>一种比 <strong>BM</strong> 算法更快的查找算法。</p><p><strong>Sunday</strong> 算法是从前往后匹配，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。</p><ul><li>如果该字符没有在模式串中出现则直接跳过，即移动位数 = 匹配串长度 + 1；</li><li>否则，其移动位数 = 模式串中最右端的该字符到末尾的距离 +1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sunday</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">text</span>, <span class="keyword">char</span> *patt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pre[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">size_t</span> *shift = pre;</span><br><span class="line">    <span class="keyword">size_t</span> i, m = <span class="built_in">strlen</span>(patt), n = <span class="built_in">strlen</span>(<span class="built_in">text</span>);</span><br><span class="line">    <span class="comment">// init</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) *(shift+i) = m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) *(shift + (<span class="keyword">unsigned</span> <span class="keyword">char</span>)(*(patt+i))) = m-i;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n-m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">memcmp</span>(patt, <span class="built_in">text</span>+i, m) == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        i += shift[<span class="built_in">text</span>[i+m]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      一些常用的字符串算法
    
    </summary>
    
    
    
      <category term="算法" scheme="http://sshpark.com.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>用C++和SFML写游戏-探索音频和文本的世界（8）</title>
    <link href="http://sshpark.com.cn/2020/04/17/%E7%94%A8C-%E5%92%8CSFML%E5%86%99%E6%B8%B8%E6%88%8F-%E6%8E%A2%E7%B4%A2%E5%A3%B0%E9%9F%B3%E5%92%8C%E6%96%87%E6%9C%AC%E7%9A%84%E4%B8%96%E7%95%8C%EF%BC%888%EF%BC%89/"/>
    <id>http://sshpark.com.cn/2020/04/17/%E7%94%A8C-%E5%92%8CSFML%E5%86%99%E6%B8%B8%E6%88%8F-%E6%8E%A2%E7%B4%A2%E5%A3%B0%E9%9F%B3%E5%92%8C%E6%96%87%E6%9C%AC%E7%9A%84%E4%B8%96%E7%95%8C%EF%BC%888%EF%BC%89/</id>
    <published>2020-04-17T06:52:13.000Z</published>
    <updated>2021-05-25T11:21:27.984Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Audio-模块概览"><a href="#1-Audio-模块概览" class="headerlink" title="1. Audio 模块概览"></a>1. Audio 模块概览</h1><p>到目前为止，我们已经用过的模块有 <strong>window，graphics 和 system</strong> 。<strong>window</strong> 模块主要用来操作窗口以及设置窗口的属性，<strong>graphics</strong> 模块为我们在屏幕绘制图形提供了一系列方便的api，在<strong>system</strong> 模块我们用到了  <code>Time</code> 类和 <code>Class</code> 类。</p><p><strong>SFML</strong> 中还有两个模块 —- <strong>audio</strong> 以及 <strong>network</strong>，后续会会慢慢介绍。</p><p>在 <strong>audio</strong> 模块中，我们必须掌握的两个类是 <code>Sf::Sound</code> 和 <code>sf::Music</code>。字面意思，两个类都是能够播放一个音频文件的。下面来简单介绍一下两者：</p><a id="more"></a><h1 id="2-Sound-与-Music"><a href="#2-Sound-与-Music" class="headerlink" title="2. Sound 与 Music"></a>2. Sound 与 Music</h1><p>实际上，这两个类的目的是不一样的，主要是因为它们的实现方式不一样。</p><p><code>Sound</code> 类会将音频文件的数据全部加载到内存中，因此它的速度是很快的。</p><p><code>Music</code> 类则是在打开了一个<strong>流</strong>连接文件所在的位置，它每次只会加载一部分的数据。因此，<code>Music</code> 类播放音频的时候会存在播放延时。</p><p>显然，由于这个特性，这两个类的应用场景有所不同。<code>Sound</code> 类会占用较多的 RAM ，而 <code>Music</code> 占用的 RAM 会很少。根据需求使用不同的类，主要是看音频文件的大小。</p><p>下面是它们的继承关系，</p><p><img src="http://sshpark.github.io/images/20200417164105.png" alt="Sound versus Music"></p><h1 id="3-Audio-实战"><a href="#3-Audio-实战" class="headerlink" title="3. Audio 实战"></a>3. Audio 实战</h1><p>音频由两个类的组合来表示，分别是 <code>Sound</code> 和 <code>SoundBuffer</code>。 <code>SoundBuffer</code> 将音频资源保存在内存中，而 <code>Sound</code> 则是解析 <code>SoundBuffer</code> 中的资源并播放。类似前面提到的使用 <code>Sprite</code> 解析 <code>Texture</code> 资源。</p><p>下面的例子展示了这一用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SFML/Audio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SFML/Window.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    sf::<span class="function">Window <span class="title">window</span><span class="params">(sf::VideoMode(<span class="number">640</span>, <span class="number">480</span>), <span class="string">"Audio"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    sf::SoundBuffer sBuffer;</span><br><span class="line">    <span class="keyword">if</span> (!sBuffer.loadFromFile(<span class="string">"../res/mySound.ogg"</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    sf::<span class="function">Sound <span class="title">sound</span><span class="params">(sBuffer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window.isOpen()) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持的音频文件格式有：<strong>OGG, WAV, FLAC 等等</strong>，注意：由于版权原因，这里不支持 MP3 格式的音频。</p><p>如果需要播放音频的话，则调用 <code>Sound::play()</code> 方法。另外，所有继承自 <code>SoundSource</code> 的类都有一个表示状态的枚举类型 <code>SoundSource::Status (enum)</code>，它包含 <code>Stopped, Paused, or Playing</code> 这三种状态。<code>getState()</code> 方法可以获取 <code>Sound</code> 实例的当前状态。</p><p>常用的方法：</p><ul><li><code>Sound::stop()</code> 停止音频，且播放位置会被重置</li><li><code>Sound::pause()</code> 暂停音频，不会重置播放位置</li><li><code>Sound::setLoop()</code> 当它为真的时候，音频将会循环播放</li><li><code>Sound::setPlayingOffset()</code> 设置音频的播放位置</li></ul><h2 id="3-1-AssetManager-2-0"><a href="#3-1-AssetManager-2-0" class="headerlink" title="3.1 AssetManager 2.0"></a>3.1 AssetManager 2.0</h2><p>还记得前面实现过的 AssetManager 吗？现在我们将音频资源也加入管理，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ASSET_MANAGER_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASSET_MANAGER_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SFML/Graphics.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SFML/Audio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssetManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AssetManager();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> sf::<span class="function">Texture&amp; <span class="title">GetTexture</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; filename)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> sf::<span class="function">SoundBuffer&amp; <span class="title">GetSoundBuffer</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; filename)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, sf::Texture&gt; m_Textures;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, sf::SoundBuffer&gt; m_SoundBuffers;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> AssetManager* sInstance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>对应的方法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sf::SoundBuffer&amp; AssetManager::GetSoundBuffer(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; filename) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; sBufferMap = sInstance-&gt;m_SoundBuffers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pairFound = sBufferMap.find(filename);</span><br><span class="line">    <span class="keyword">if</span> (pairFound != sBufferMap.end()) &#123;</span><br><span class="line">        <span class="keyword">return</span> pairFound-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; sBuffer = sBufferMap[filename];</span><br><span class="line">    sBuffer.loadFromFile(filename);</span><br><span class="line">    <span class="keyword">return</span> sBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个之后，可以通过以下方式使用音频文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example_8_1.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    sf::<span class="function">Window <span class="title">window</span><span class="params">(sf::VideoMode(<span class="number">640</span>, <span class="number">480</span>), <span class="string">"Audio"</span>)</span></span>;</span><br><span class="line">    AssetManager manager;</span><br><span class="line"></span><br><span class="line">    sf::<span class="function">Sound <span class="title">sound</span><span class="params">(AssetManager::GetSoundBuffer(<span class="string">"../res/mySound.ogg"</span>))</span></span>;</span><br><span class="line">    sound.play();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window.isOpen()) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-sf-Music"><a href="#3-2-sf-Music" class="headerlink" title="3.2 sf::Music"></a>3.2 sf::Music</h2><p>使用 <code>Music</code> 类播放音频如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sf::Music music;</span><br><span class="line">if (!music.openFromFile('myMusic.ogg'))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">music.play()</span><br></pre></td></tr></table></figure><p>调用 <code>play()</code> 方法会以一个单独的线程运行，因此不用它会阻塞当前线程。</p><h1 id="4-sf-SoundSource-和-3D-音效"><a href="#4-sf-SoundSource-和-3D-音效" class="headerlink" title="4. sf::SoundSource 和 3D 音效"></a>4. sf::SoundSource 和 3D 音效</h1><p>使用 <code>SoundSource::setVolume()</code> 可以设置音量，支持的音量值从 0（静音）到100（最大音量），默认值都为100。我们可以使用SoundSource :: getVolume（）获取当前音量。</p><p>如何将声音以<strong>空间化</strong>的方式呈现出来，也就是说，如果有一个爆炸音效发生在游戏角色的左侧，那么玩家的左耳听到的声音应该要大一些。接下来简单实现一下</p><h2 id="4-1-设置-listener"><a href="#4-1-设置-listener" class="headerlink" title="4.1 设置 listener"></a>4.1 设置 listener</h2><p><strong>SFML</strong> 为我们提供了一个静态类 <code>sf::Listener</code> 来设置我们的 <strong>Listener</strong>。有三个属性可以设置，分别是 <strong>position（位置）, orientation（方向）, and global volume（音量大小）</strong></p><p><code>Listener::setPosition()</code> 需要传入一个三维向量参数，作用是设置 <strong>Listener</strong> 的位置， 默认声音的产生是在三维空间中的，对于 2D 游戏，可以将 z 轴设置为 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sf::<span class="function">Sprite <span class="title">heroSprite</span><span class="params">(AssetManager::GetTexture(<span class="string">"myhero.png"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (window.isOpen()) &#123;</span><br><span class="line">    sf::Vector2f heroPos = heroSprite.getPosition();</span><br><span class="line">    sf::Listener::setPosition(heroPos.x, heroPos.y, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Listener::setDirection()</code> 同样需要传入一个三维向量参数，作用是设置 <strong>Listener</strong> 的朝向。示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI_RADIANS 3.1415f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI_DEGREES 180.f</span></span><br><span class="line"></span><br><span class="line">sf::<span class="function">Sprite <span class="title">heroSprite</span><span class="params">(AssetManager::GetTexture(<span class="string">"myHero.png"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (window.isOpen()) &#123;</span><br><span class="line">    <span class="keyword">float</span> heroRot = heroSprite.getRotation() * PI_RADIANS / PI_DEGREES;</span><br><span class="line">    </span><br><span class="line">    sf::Listener::setDirection(<span class="built_in">std</span>::<span class="built_in">cos</span>(heroRot), <span class="built_in">std</span>::<span class="built_in">sin</span>(heroRot), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-sf-Text-的使用"><a href="#5-sf-Text-的使用" class="headerlink" title="5. sf::Text 的使用"></a>5. sf::Text 的使用</h1><p>文本是游戏中最容易被忽视的功能之一，但有时对于游戏体验来说也是必不可少的，例如，使用正确的字体和大小，显示适当的信息量等等。 有些游戏甚至不会设置字体，但是很少见。 我们将讨论<strong>文本（text）和字体（font）</strong>。</p><p>使用特定字体（font）设置文本（text），如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sf::Font font;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!font.loadFromFile(<span class="string">"awesomeFont.ttf"</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">sf::<span class="function">Text <span class="title">text</span><span class="params">(<span class="string">"Look at my awesome font"</span>, font)</span></span>;</span><br></pre></td></tr></table></figure><p>使用 <code>RenderWindow::draw()</code> 方法可以将 text 绘制到窗口中。</p><p>text 常用的方法有：</p><ul><li><code>Text::setColor()</code> 设置 text 的颜色</li><li><code>Text::setStyle()</code> 设置 text 的各种属性，例如 <code>Text::Style::Regular, Text::Style::Bold, Text::Style::Italic</code>, 以及 <code>Text::Style::Underlined</code></li></ul><h2 id="5-1-AssetManaget-3-0"><a href="#5-1-AssetManaget-3-0" class="headerlink" title="5.1 AssetManaget 3.0"></a>5.1 AssetManaget 3.0</h2><p>将 <code>Font</code> 类加入到我们的资源管理类中，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssetManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AssetManager();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> sf::<span class="function">Texture&amp; <span class="title">GetTexture</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; filename)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> sf::<span class="function">SoundBuffer&amp; <span class="title">GetSoundBuffer</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; filename)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> sf::<span class="function">Font&amp; <span class="title">GetFont</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; filename)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, sf::Texture&gt; m_Textures;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, sf::SoundBuffer&gt; m_SoundBuffers;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, sf::Font&gt; m_Fonts;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> AssetManager* sInstance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>AssetManager::GetFont()</code> 方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sf::Font&amp; AssetManager::GetFont(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; fontMap = sInstance-&gt;m_Fonts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pairFound = fontMap.find(filename);</span><br><span class="line">    <span class="keyword">if</span> (pairFound != fontMap.end()) &#123;</span><br><span class="line">        <span class="keyword">return</span> pairFound-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; font = fontMap[filename];</span><br><span class="line">    font.loadFromFile(filename);</span><br><span class="line">    <span class="keyword">return</span> font;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以支持的 font 文件类型有：<strong>TrueType (TTF), Type 1, CFF, OpenType, SFNT, X11 PCF, Windows FNT, BDF, PFR, and Type 42</strong></p><h1 id="6-最后"><a href="#6-最后" class="headerlink" title="6. 最后"></a>6. 最后</h1><p>本文主要介绍了 <strong>SFML</strong> 中 <strong>Audio</strong> 模块的基本用法。后面也简单介绍了一下 text 和 font 的问题。</p><p>接下来将会介绍 <strong>SFML</strong> 中关于 <strong>network</strong> 模块的用法。😁</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Audio-模块概览&quot;&gt;&lt;a href=&quot;#1-Audio-模块概览&quot; class=&quot;headerlink&quot; title=&quot;1. Audio 模块概览&quot;&gt;&lt;/a&gt;1. Audio 模块概览&lt;/h1&gt;&lt;p&gt;到目前为止，我们已经用过的模块有 &lt;strong&gt;window，graphics 和 system&lt;/strong&gt; 。&lt;strong&gt;window&lt;/strong&gt; 模块主要用来操作窗口以及设置窗口的属性，&lt;strong&gt;graphics&lt;/strong&gt; 模块为我们在屏幕绘制图形提供了一系列方便的api，在&lt;strong&gt;system&lt;/strong&gt; 模块我们用到了  &lt;code&gt;Time&lt;/code&gt; 类和 &lt;code&gt;Class&lt;/code&gt; 类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SFML&lt;/strong&gt; 中还有两个模块 —- &lt;strong&gt;audio&lt;/strong&gt; 以及 &lt;strong&gt;network&lt;/strong&gt;，后续会会慢慢介绍。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;audio&lt;/strong&gt; 模块中，我们必须掌握的两个类是 &lt;code&gt;Sf::Sound&lt;/code&gt; 和 &lt;code&gt;sf::Music&lt;/code&gt;。字面意思，两个类都是能够播放一个音频文件的。下面来简单介绍一下两者：&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="SFML" scheme="http://sshpark.com.cn/tags/SFML/"/>
    
      <category term="用C++和SFML写游戏" scheme="http://sshpark.com.cn/tags/%E7%94%A8C-%E5%92%8CSFML%E5%86%99%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Softmax 回归反向传播推导</title>
    <link href="http://sshpark.com.cn/2020/03/02/Softmax-%E5%9B%9E%E5%BD%92%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%8E%A8%E5%AF%BC/"/>
    <id>http://sshpark.com.cn/2020/03/02/Softmax-%E5%9B%9E%E5%BD%92%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%8E%A8%E5%AF%BC/</id>
    <published>2020-03-02T15:21:20.000Z</published>
    <updated>2021-05-25T11:21:27.970Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://sshpark.github.io/images/20200302232251.jpeg" alt=""></p><p><img src="http://sshpark.github.io/images/20200302232301.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      基础，记录一下
    
    </summary>
    
    
    
      <category term="机器学习" scheme="http://sshpark.com.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Logistic regression 反向传播推导（带L2正则）</title>
    <link href="http://sshpark.com.cn/2020/02/21/Logistic-regression-%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%8E%A8%E5%AF%BC/"/>
    <id>http://sshpark.com.cn/2020/02/21/Logistic-regression-%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%8E%A8%E5%AF%BC/</id>
    <published>2020-02-21T14:15:30.000Z</published>
    <updated>2021-05-25T11:21:28.025Z</updated>
    
    <content type="html"><![CDATA[<p>懒得打公式了。。。</p><p><img src="http://sshpark.github.io/images/20200221225601.jpeg" alt="推导过程"></p>]]></content>
    
    <summary type="html">
    
      做个笔记📒
    
    </summary>
    
    
    
      <category term="机器学习" scheme="http://sshpark.com.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SFML 2.5.1 下载地址</title>
    <link href="http://sshpark.com.cn/2020/01/04/SFML-2-5-1-%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/"/>
    <id>http://sshpark.com.cn/2020/01/04/SFML-2-5-1-%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/</id>
    <published>2020-01-04T01:55:18.000Z</published>
    <updated>2021-05-25T11:21:27.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Download-SFML-2-5-1"><a href="#Download-SFML-2-5-1" class="headerlink" title="Download SFML 2.5.1"></a>Download SFML 2.5.1</h1><p>由于国内网络原因，需要科学上网才能下载到 SFML 安装包，这里将常用的 SFML 版本放在了百度盘上方便大家下载。</p><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>On Windows, choosing 32 or 64-bit libraries should be based on which platform you want to compile for, not which OS you have. Indeed, you can perfectly compile and run a 32-bit program on a 64-bit Windows. So you’ll most likely want to target 32-bit platforms, to have the largest possible audience. Choose 64-bit packages only if you have good reasons.</p><div class="table-container"><table><thead><tr><th>Visual C++ 15 (2017) - 32-bit</th><th>Visual C++ 15 (2017) - 64-bit</th></tr></thead><tbody><tr><td><a href="https://pan.baidu.com/s/1wk6Ld3AfnctrLdPpj5aAOA" target="_blank" rel="noopener">Download16.3 MB</a></td><td><a href="https://pan.baidu.com/s/17dM9p6hTXH3hgVOKl5iQvw" target="_blank" rel="noopener">Download18.0 MB</a></td></tr></tbody></table></div><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>LinuxGCC - 64-bit <a href="https://pan.baidu.com/s/1nzbX9raiVZcuS6upP1Nl_A" target="_blank" rel="noopener">Download2.21 MB</a></p><h2 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h2><p>Clang - 64-bit (OS X 10.7+, compatible with C++11 and libc++)<a href="https://pan.baidu.com/s/1ThBBqORLiZyRGnUlTKtgWA" target="_blank" rel="noopener">Download5.50 MB</a></p>]]></content>
    
    <summary type="html">
    
      SFML 常用版本国内下载
    
    </summary>
    
    
    
      <category term="资源下载" scheme="http://sshpark.com.cn/tags/%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/"/>
    
      <category term="SFML" scheme="http://sshpark.com.cn/tags/SFML/"/>
    
  </entry>
  
  <entry>
    <title>biweekly-contest-16</title>
    <link href="http://sshpark.com.cn/2019/12/29/biweekly-contest-16/"/>
    <id>http://sshpark.com.cn/2019/12/29/biweekly-contest-16/</id>
    <published>2019-12-29T09:04:41.000Z</published>
    <updated>2021-05-25T11:21:27.963Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://sshpark.github.io/images/20191229170510.png" alt=""></p><h2 id="5134-将每个元素替换为右侧最大元素"><a href="#5134-将每个元素替换为右侧最大元素" class="headerlink" title="5134. 将每个元素替换为右侧最大元素"></a><a href="https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side/" target="_blank" rel="noopener">5134. 将每个元素替换为右侧最大元素</a></h2><p>给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。</p><p>完成所有替换操作后，请你返回这个数组。</p><p><strong>示例：</strong></p><blockquote><p>  输入：arr = [17,18,5,4,6,1]</p><p>  输出：[18,6,6,6,1,-1]</p></blockquote><p><strong>提示：</strong></p><p>$1 &lt;= arr.length &lt;= 10^4$</p><p>$1 &lt;= arr[i] &lt;= 10^5$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>从后往前扫描，并且记录最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; replaceElements(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> maxa = arr[n<span class="number">-1</span>];</span><br><span class="line">        arr[n<span class="number">-1</span>] = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = maxa;</span><br><span class="line">            <span class="keyword">if</span> (maxa &lt; temp) maxa = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5135-转变数组后最接近目标值的数组和"><a href="#5135-转变数组后最接近目标值的数组和" class="headerlink" title="5135. 转变数组后最接近目标值的数组和"></a><a href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/" target="_blank" rel="noopener">5135. 转变数组后最接近目标值的数组和</a></h2><p>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。</p><p>如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。</p><p>请注意，答案不一定是 arr 中的数字。</p><p>示例 1：</p><blockquote><p>  输入：arr = [4,9,3], target = 10</p><p>  输出：3</p><p>  解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。</p></blockquote><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>先排序，然后前缀和预处理 arr 数组，然后从 0 开始遍历答案，因为 arr 已经排序了，所以计算差异的时候使用二分。总的时间复杂度是 $O(nlogn)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBestValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        sort(arr.begin(), arr.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> psum[n+<span class="number">1</span>], r = <span class="number">-1</span>;</span><br><span class="line">        psum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            psum[i] = psum[i<span class="number">-1</span>] + arr[i<span class="number">-1</span>];</span><br><span class="line">            r = max(r, arr[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">100000000</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(arr.begin(), arr.end(), i) - arr.begin();</span><br><span class="line">            <span class="keyword">int</span> temp = psum[pos]+(n-pos)*i;</span><br><span class="line">            <span class="keyword">int</span> last = diff;</span><br><span class="line">            diff = <span class="built_in">abs</span>(temp-target);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (diff &gt;= last)</span><br><span class="line">                <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5153-层数最深叶子节点的和"><a href="#5153-层数最深叶子节点的和" class="headerlink" title="5153. 层数最深叶子节点的和"></a><a href="https://leetcode-cn.com/problems/deepest-leaves-sum/" target="_blank" rel="noopener">5153. 层数最深叶子节点的和</a></h2><p>给你一棵二叉树，请你返回层数最深的叶子节点的和。</p><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>BFS 遍历记录每一层椰子节点的和，遍历完成也就是最深的叶子结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deepestLeavesSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">int</span> sum;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = q.size();</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                TreeNode* top = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                sum += top-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (top-&gt;left != <span class="literal">NULL</span>) q.push(top-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (top-&gt;right != <span class="literal">NULL</span>) q.push(top-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5137-最大得分的路径数目"><a href="#5137-最大得分的路径数目" class="headerlink" title="5137. 最大得分的路径数目"></a><a href="https://leetcode-cn.com/problems/number-of-paths-with-max-score/" target="_blank" rel="noopener">5137. 最大得分的路径数目</a></h2><p>给你一个正方形字符数组 board ，你从数组最右下方的字符 <code>&#39;S&#39;</code> 出发。</p><p>你的目标是到达数组最左上角的字符 ‘E’ ，数组剩余的部分为数字字符 <code>1, 2, ..., 9</code> 或者障碍 <code>&#39;X&#39;</code>。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。</p><p>一条路径的 「得分」 定义为：路径上所有数字的和。</p><p>请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对 $10^9 + 7$ 取余。</p><p>如果没有任何路径可以到达终点，请返回 [0, 0] 。</p><p><strong>示例 1：</strong></p><blockquote><p>  输入：board = [“E23”,”2X2”,”12S”]<br>  输出：[7,1]</p></blockquote><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>这题用动态规划做还是比较明显的，第一问有点类似动态规划的经典入门题 <strong>数字三角形</strong> 。熟悉动态规划的话转移方程的话比较容易想到</p><script type="math/tex; mode=display">dp[i][j] = \max \{ dp[i-1][j-1], max \{ dp[i-1][k], dp[i][j-1] \} \} \quad i, j \in (0, n)</script><p>对于统计方案数，我们需要记录上面方程的转移过程，在转移的时候更新方案数。</p><p>注意一下边界的初始化以及走不通的情况判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pathsWithMaxScore(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; board) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dp[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> dp1[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(dp1, <span class="number">0</span>, <span class="keyword">sizeof</span> dp1);</span><br><span class="line">        dp1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        board[n<span class="number">-1</span>][n<span class="number">-1</span>]= <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][i] != <span class="string">'X'</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>]+board[<span class="number">0</span>][i]-<span class="string">'0'</span>;</span><br><span class="line">                dp1[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] != <span class="string">'X'</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]+board[i][<span class="number">0</span>]-<span class="string">'0'</span>;</span><br><span class="line">                dp1[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'X'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                    <span class="keyword">int</span> b = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">int</span> c = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">int</span> temp = max(a, max(b, c));</span><br><span class="line">                    dp[i][j] = temp+board[i][j]-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (temp == <span class="number">0</span> &amp;&amp; dp1[i<span class="number">-1</span>][j] == <span class="number">0</span> &amp;&amp; dp1[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">0</span> &amp;&amp; dp1[i][j<span class="number">-1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                        dp1[i][j] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (a == temp) dp1[i][j] += dp1[i<span class="number">-1</span>][j]%mod;</span><br><span class="line">                    <span class="keyword">if</span> (b == temp) dp1[i][j] += dp1[i<span class="number">-1</span>][j<span class="number">-1</span>]%mod;</span><br><span class="line">                    <span class="keyword">if</span> (c == temp) dp1[i][j] += dp1[i][j<span class="number">-1</span>]%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; n; j++)</span></span><br><span class="line">        <span class="comment">//         printf("%d ", dp1[i][j]);</span></span><br><span class="line">        <span class="comment">//     printf("\n");</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//printf("%d\n", dp[n-1][n-1]);</span></span><br><span class="line">        <span class="keyword">return</span> &#123;dp[n<span class="number">-1</span>][n<span class="number">-1</span>], dp1[n<span class="number">-1</span>][n<span class="number">-1</span>]%mod&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      好久没刷 leetcode，现在居然出了夜喵专场。比赛结束的时候已经凌晨 12 点了。这一场主要的用到的知识有动态规划，BFS。
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://sshpark.com.cn/tags/LeetCode/"/>
    
      <category term="bfs" scheme="http://sshpark.com.cn/tags/bfs/"/>
    
      <category term="动态规划" scheme="http://sshpark.com.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>《敏捷项目管理》知识要点整理</title>
    <link href="http://sshpark.com.cn/2019/12/27/%E3%80%8A%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E3%80%8B%E7%9F%A5%E8%AF%86%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://sshpark.com.cn/2019/12/27/%E3%80%8A%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E3%80%8B%E7%9F%A5%E8%AF%86%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2019-12-27T01:48:42.000Z</published>
    <updated>2021-05-25T11:22:02.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h1><p>1、拥有特定的目标</p><p>2、临时性：具有明确的开始和结束时间</p><p>3、使用逐步细化的方式进行开发</p><p>4、通常需要不同领域的资源</p><p>5、应该要有一个主要的客户或者赞助商</p><p>6、不确定性</p><h1 id="什么是项目管理"><a href="#什么是项目管理" class="headerlink" title="什么是项目管理"></a>什么是项目管理</h1><p>将知识，技能，工具和技术应用于项目活动中以满足项目要求</p><h1 id="传统项目管理中一些概念"><a href="#传统项目管理中一些概念" class="headerlink" title="传统项目管理中一些概念"></a>传统项目管理中一些概念</h1><p><strong>stakeholder</strong></p><p>是<strong>参与</strong>或<strong>受项目活动影响</strong>的人<br>包含有：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、the project sponsor</span><br><span class="line">2、the project manager：97% of successful projects were led by &lt;font color="red"&gt;experienced&lt;/font&gt; project managers, who can often help influence success factors</span><br><span class="line">3、the project team</span><br><span class="line">4、support staff</span><br><span class="line">5、customers</span><br><span class="line">6、users</span><br><span class="line">7、suppliers</span><br><span class="line">8、opponents to the project</span><br></pre></td></tr></table></figure><p><strong>项目经理最重要的十项技能和能力</strong></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">人际交往技巧</span><br><span class="line">领导力</span><br><span class="line">倾听</span><br><span class="line">正直，道德行为，始终如一</span><br><span class="line">善于建立信任</span><br><span class="line">口头交流</span><br><span class="line">善于建立团队</span><br><span class="line">冲突解决，冲突管理</span><br><span class="line">批判性思维，解决问题</span><br><span class="line">理解并平衡优先事项</span><br></pre></td></tr></table></figure><p><strong>领导技能的重要性</strong></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">高效的项目经理以身作则提供领导力</span><br><span class="line">领导者关注长期目标和大局目标，同时激励人们实现这些目标</span><br><span class="line">经理负责实现具体目标的日常细节</span><br><span class="line">项目经理经常同时扮演领导者和经理的角色</span><br></pre></td></tr></table></figure><h1 id="互联网-时代软件产品开发的变化"><a href="#互联网-时代软件产品开发的变化" class="headerlink" title="互联网+时代软件产品开发的变化"></a>互联网+时代软件产品开发的变化</h1><ul><li>以用户为中心，而非客户</li><li>从不确定性出发，而非确定性</li><li>主导产品，而非交付项目</li><li>追求体验，而非质量</li><li>追求容错，而非完美</li><li>追求创新，而非执行</li></ul><h1 id="敏捷的背景与动机"><a href="#敏捷的背景与动机" class="headerlink" title="敏捷的背景与动机"></a>敏捷的背景与动机</h1><ul><li>软件危机及软件工程的出现</li><li>速度是企业竞争致胜的关键因素，软件项目的最大挑战在于<ul><li>一方面要应付变动中的需求</li><li>一方面要在紧缩的时程内完成项目</li></ul></li><li>传统的软件工程难以满足这些要求</li><li>所以软件团队除了在技术上必须日益精进，更需要运用有效的开发流程，以确保团队能够发挥综效。这正是 Agile Process（敏捷的软件开发流程）于近年来兴起的主要原因。</li></ul><h1 id="什么是敏捷软件开发方法"><a href="#什么是敏捷软件开发方法" class="headerlink" title="什么是敏捷软件开发方法"></a>什么是敏捷软件开发方法</h1><ul><li>敏捷方法是一类软件开发流程的泛称</li><li>敏捷方法是相对于传统的软件过程提出的</li><li>敏捷方法可以用敏捷宣言（4条）、敏捷原则（12条）和 一系列的敏捷实践来概括</li><li>敏捷方法有很多软件开发框架</li></ul><h1 id="敏捷价值观之敏捷宣言（4点）"><a href="#敏捷价值观之敏捷宣言（4点）" class="headerlink" title="敏捷价值观之敏捷宣言（4点）"></a>敏捷价值观之敏捷宣言（4点）</h1><ul><li>个体和交互胜过过程和工具</li><li>可以工作的软件胜过面面俱到的文档</li><li>客户合作胜过合同谈判</li><li>响应变化胜过循环计划</li></ul><h1 id="敏捷开发的12-个原则"><a href="#敏捷开发的12-个原则" class="headerlink" title="敏捷开发的12 个原则"></a>敏捷开发的12 个原则</h1><ul><li>我们最优先要做的是通过尽早的、持续的交付有价值的软件来使客户满意</li><li>即使到了开发的后期，也欢迎改变需求</li><li>经常性地交付可以工作的软件，交付的间隔可以从几周到几个月，交付的时间间隔越短越好</li><li>在整个项目开发期间，业务人员和开发人员必须天天都在一起工作</li><li>项目由有激情的、值得信任的个体合作完成</li><li>在团队内部，最具有效果并且富有效率的传递信息的方法，就是面对面的交谈</li><li>工作的软件是首要的进度度量标准</li><li>敏捷过程提倡平稳的开发节奏；发起人、开发者和用户 应该能够保持一个长期的、恒定的开发速度</li><li>不断地关注优秀的技术和好的设计可以增强敏捷能力</li><li>简单化是根本（不做过度设计和预测）</li><li>最好的构架、需求和设计是来源于自组织的团队</li><li>每隔一定时间，团队会在如何才能更有效地工作方面进行反思，并对自己的行为进行相应调整</li></ul><h1 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h1><p>Scrum先开发的是对客户具有较高价值的需求，在每个迭代结束后，都会开发完成可交付的产品</p><p>术语：</p><ul><li><strong>Sprint（冲刺）</strong>一个小的迭代周期</li><li><strong>Backlog</strong> 按照商业价值排序的需求表, backlog意为“积压的工作”</li><li><strong>Burndown chart</strong> 燃尽图，记录迭代的进度 </li><li><strong>User Story</strong> 用户故事，用于描述需求</li></ul><h1 id="Scrum敏捷开发的框架"><a href="#Scrum敏捷开发的框架" class="headerlink" title="Scrum敏捷开发的框架"></a>Scrum敏捷开发的框架</h1><p><img src="http://sshpark.github.io/images/15774110956879" alt="24"></p><h1 id="Scrum-角色"><a href="#Scrum-角色" class="headerlink" title="Scrum 角色"></a>Scrum 角色</h1><p><img src="http://sshpark.github.io/images/15774110960211" alt="14" style="zoom:33%;" /></p><p><strong>Product owner（产品负责人）:</strong> 是利益相关方的代表，他的工作重点是产品的业务方面，他负责向团队介绍产品愿景那个。负责给出一份明确的，可度量的，合理的产品backlog，并从业务角度出发对backlog中各项问题按优先级排序。</p><p><img src="http://sshpark.github.io/images/15774110965261" style="zoom:33%;" /></p><p><img src="http://sshpark.github.io/images/15774110969612" style="zoom: 33%;" /></p><p><strong>Scrum Master：</strong>是整个团队的导师和组织者，他负责提高团队的开发效率，他常提出培训团队的计划，列出障碍 Backlog。Scrum Master 控制着检查和改进 Scrum 的周期，他维护这一团队的正常运行，并与产品负责人一起让利益相关方获得最大化投资回报。他关心的是这些敏捷开发思想是否能够得到利益相关方的理解和支持。</p><p><img src="http://sshpark.github.io/images/15774110973897" style="zoom:33%;" /></p><p><img src="http://sshpark.github.io/images/15774110979805" style="zoom:33%;" /></p><p><strong>团队</strong></p><p><img src="http://sshpark.github.io/images/15774110985383" style="zoom:33%;" /></p><p><strong>技术负责人</strong></p><p><strong>Stakeholder：</strong>是<strong>参与</strong>或<strong>受项目活动影响</strong>的人</p><p><strong>Agile Mentor</strong></p><h2 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h2><p>团队成员特质：<br>• 创建产品<br>• 自组织、自管理<br>• 跨职能工作<br>• 专注且集中办公</p><h1 id="Scrum-Artifacts（可交付成果，工件）"><a href="#Scrum-Artifacts（可交付成果，工件）" class="headerlink" title="Scrum Artifacts（可交付成果，工件）"></a>Scrum Artifacts（可交付成果，工件）</h1><ul><li>Product backlog（产品代办列表）：按照业务价值进行优先级排序的功能列表</li><li>Sprint backlog（冲刺待办列表）：product backlog 中具有最高优先级的事项，将在一个 sprint （冲刺）中完成</li><li>Product Increment（产品增量）：交付可用的产品</li><li>Burndown chart（燃尽图）：展示了一个冲刺中每天的剩余工作量</li></ul><h1 id="Scrum-Ceremonies（仪式）"><a href="#Scrum-Ceremonies（仪式）" class="headerlink" title="Scrum Ceremonies（仪式）"></a>Scrum Ceremonies（仪式）</h1><ul><li>sprint planning session（冲刺计划会议）：团队举行的会议，从 product backlog 中选择一组工作在下一次的冲刺中完成。</li><li>Daily Scrum（每日例会）：开发团队举行的一个简短会议，主要分享进度以及遇到的挑战，以及计划一天的工作。</li><li>Sprint reviews（冲刺评审会议）：团队在会议中向利益相关者和 product owner 演示在冲刺过程中已完成的工作。</li><li>Sprint retrospective（冲刺回顾）：根据开发团队的实际表现进行的会议过程，寻找改进产品的方法</li></ul><h1 id="Scrum-特点"><a href="#Scrum-特点" class="headerlink" title="Scrum 特点"></a>Scrum 特点</h1><p><img src="http://sshpark.github.io/images/15774110988498" alt="25" style="zoom: 50%;" /></p><h1 id="Scrum-框架"><a href="#Scrum-框架" class="headerlink" title="Scrum 框架"></a>Scrum 框架</h1><p><img src="http://sshpark.github.io/images/15774110990615" style="zoom:33%;" /></p><h1 id="价值路线图"><a href="#价值路线图" class="headerlink" title="价值路线图"></a>价值路线图</h1><p><img src="http://sshpark.github.io/images/15774110994384" alt=""></p><h1 id="产品愿景（product-vision）"><a href="#产品愿景（product-vision）" class="headerlink" title="产品愿景（product vision）"></a>产品愿景（product vision）</h1><p>创建产品愿景声明的步骤： </p><ol><li><p>设定产品目标：需要考虑产品的关键目标、客户分析、需求、竞争者、主要差异</p></li><li><p>创建愿景声明的草案：</p><p> <img src="http://sshpark.github.io/images/15774110998930" style="zoom:43%;" /></p></li><li><p>与项目干系人共同确认愿景草案，并修改</p></li><li><p>确定愿景草案</p></li></ol><h1 id="创建产品路线图"><a href="#创建产品路线图" class="headerlink" title="创建产品路线图"></a>创建产品路线图</h1><p>产品路线图是指产品需求的综合提示图，是产品需求的概览，也 是组织开发过程的工具</p><p>与创建愿景相比，开发团队参与程度更大</p><font color="blue">**创建步骤：**</font><ol><li><p><strong>识别产品需求</strong></p></li><li><p><strong>整理</strong>（功能features）</p></li><li><p><strong>产品特性的估算和排序</strong></p><p> 目的：确定核心需求，识别需求差异</p><p> 给需求的<font color="red">价值</font>和<font color="red">工作量</font>打分</p><p> 用Fibonacci数列作为分值： 用相对分数</p><ul><li>产品路线图的需求：分数在55—144 （主题、特性）</li><li>发布计划的需求：分数在13—34 （史诗故事）</li><li>冲刺计划的需求：分数在1—8 （用户故事）</li></ul></li><li><p><strong>决定大致的时间框架</strong></p></li></ol><h2 id="识别产品需求"><a href="#识别产品需求" class="headerlink" title="识别产品需求"></a>识别产品需求</h2><p>通过愿景声明，确定需求的主题 —— 是最高层次的需求</p><p>分析需求主题的特性，即拆分为具有若干特性的需求</p><h2 id="整理产品特性"><a href="#整理产品特性" class="headerlink" title="整理产品特性"></a>整理产品特性</h2><p>实例<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">• 主题：移动银行应用</span><br><span class="line">• 特性：账户管理、交易管理、客服管理</span><br><span class="line">• 史诗故事：</span><br><span class="line">• 账户信息：登录验证、VIP、个人信息修改</span><br><span class="line">• 交易管理：支付、账单管理</span><br><span class="line">• 客服功能：查询余额、理财、自动付款</span><br><span class="line">• 用户故事：登录验证、VIP、个人信息修改、支付、账单管理、</span><br><span class="line">查询余额、理财、自动付款</span><br><span class="line">• 任务：登录验证：输入用户名/账号，输入密码…</span><br></pre></td></tr></table></figure></p><h2 id="工作量估算方法"><a href="#工作量估算方法" class="headerlink" title="工作量估算方法"></a>工作量估算方法</h2><ol><li><p><strong>绝对估算法：</strong>以人时或人日为估算单位。但是，在计算优先级时，数据不能统一，即用户故事的价值值如 果随意取，则算出来的优先级难于理解。</p></li><li><p><strong>相对估算法：</strong>也称为故事点(Story Point)估算法：选择一个较小的用户故事，给出故事点数，以此为基准，估算其他用户故事的故事点数。</p></li><li><p><strong>使用斐波那契数列打分的理由：</strong>故事点估算使用斐波那契数列，用户故事越大，则数字间距越大，工作 量增长得也越快 也可以使用自然数列或其他数值，但是斐波那契数列的值会更符合用户 故事价值和工作量的估算对应，数据不太多，也不太少，容易建立多人 统一的打分标准。即分数与价值（或工作量）相对应。</p></li><li><p><strong>相对优先级=价值/工作量</strong></p></li></ol><h2 id="决定产品特性的时间框架"><a href="#决定产品特性的时间框架" class="headerlink" title="决定产品特性的时间框架"></a>决定产品特性的时间框架</h2><ul><li>根据产品特性的<strong>相对优先级排序</strong>，创建产品路线图</li><li>优先级<strong>高的排在</strong>完成时间的<strong>前面</strong></li><li>当确定了产品路线图，可以<strong>确定产品发布时间</strong></li><li>根据产品发布的优先级，确定大致的<strong>产品迭代时间增量</strong></li></ul><p>例如：</p><p><img src="http://sshpark.github.io/images/15774111001265" alt=""></p><h1 id="创建-Product-Backlog"><a href="#创建-Product-Backlog" class="headerlink" title="创建 Product Backlog"></a>创建 Product Backlog</h1><p>Product Backlog是指确定了用户故事优先级的用户故事列表，例：</p><p><img src="http://sshpark.github.io/images/15774111004144" alt=""></p><h1 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h1><p>用户故事：是指一种对某个产品需求的简单描述（结合需求分析的用例图）</p><p>用户故事卡片：</p><ul><li>标题&lt;名称&gt; </li><li>作为&lt;用户 或 角色&gt;<font color="red">*</font> </li><li>我想&lt;采取的行动&gt; <font color="red">*</font></li><li>以便&lt;能获得的益处&gt;</li></ul><p>注意：</p><ul><li>发布级别的用户故事个数要求不超过<strong>34</strong>个故事点</li><li>冲刺级别的用户故事个数要求不超过<strong>8</strong>个故事点，每个故事点要分解为多个任务</li></ul><h2 id="分割用户故事的原则"><a href="#分割用户故事的原则" class="headerlink" title="分割用户故事的原则"></a>分割用户故事的原则</h2><ul><li>按照用户故事<strong>所支持数据的边界</strong>分割大型用户故事（例如导入GBQ文件、Excel等）</li><li><strong>按照操作边界分割</strong>，把大型用户故事分割成独立的建立、读取、更新和删除操作</li><li>考虑去除横切功能（例如安全处理、日志记录、错误处理等），为用户故事建立两个版本：一个 具备对横切功能的支持，另一个不具备这种支持</li><li>考虑功能性需求和非功能性需求隔离到不同的用户故事，从而分割大型用户故事（性能）</li></ul><h2 id="确保用户故事质量的INVEST方法"><a href="#确保用户故事质量的INVEST方法" class="headerlink" title="确保用户故事质量的INVEST方法"></a>确保用户故事质量的INVEST方法</h2><ol><li>独立的</li><li>可协商的</li><li>有价值的</li><li>可估算的</li><li>小型的</li><li>可测试的</li></ol><h2 id="用户故事的描述"><a href="#用户故事的描述" class="headerlink" title="用户故事的描述"></a>用户故事的描述</h2><ul><li>用户故事的形式很自由，没有什么强制性的语法</li><li>故事大致可符合这样的形式：“作为【用户的类型】，我希望可以 【先这样做，然后那样做，就应该得到…的结果】以便【业务价值】</li><li>用户故事的三要素：<ol><li>角色（who）：谁要使用这个</li><li>功能（what）：要完成什么功能</li><li>价值（value）：为什么要这么做，这么做能带来什么价值</li></ol></li></ul><h2 id="用户故事与用例的差异"><a href="#用户故事与用例的差异" class="headerlink" title="用户故事与用例的差异"></a>用户故事与用例的差异</h2><ul><li>用户故事的详细信息可能不会与用例记录在同一极端。</li><li>用户故事故意遗漏了许多重要细节。用户故事旨在通过在Scrum会议期间提问来引发对话。</li><li>用户故事用于更频繁地获得反馈的小增量，而不是像用例中那样具有更详细的前期需求规范。</li></ul><h2 id="估算用户故事的工具-估算扑克"><a href="#估算用户故事的工具-估算扑克" class="headerlink" title="估算用户故事的工具-估算扑克"></a>估算用户故事的工具-估算扑克</h2><p>例如：研发团队用估算扑克估算工作量</p><p><img src="http://sshpark.github.io/images/15774111006146" style="zoom: 50%;" /></p><h2 id="如何优化用户故事的估算"><a href="#如何优化用户故事的估算" class="headerlink" title="如何优化用户故事的估算"></a>如何优化用户故事的估算</h2><ul><li>确定用户故事的规模类别：非常小型、小型、中型、大型、非常大型、史诗故事</li><li>PO评审用户故事类别</li><li>成员给类别打分</li><li>成员给用户故事归类</li></ul><h2 id="如果有很多用户故事的时候，该怎么办？"><a href="#如果有很多用户故事的时候，该怎么办？" class="headerlink" title="如果有很多用户故事的时候，该怎么办？"></a>如果有很多用户故事的时候，该怎么办？</h2><p>使用<strong>相似估算</strong>，因为其中很多的故事非常相似。</p><p>1、确定故事的类型</p><p>2、将故事进行分类</p><p>3、开发团队评审并调整用户故事的位置</p><p>4、产品负责人进行评审</p><p>5、如果开发团队与产品负责人的期望估算值相差超过了一个尺寸时，他们会讨论这则用户故事。开发团队最终决定是否调整这则用户故事。</p><h1 id="计划发布与冲刺"><a href="#计划发布与冲刺" class="headerlink" title="计划发布与冲刺"></a>计划发布与冲刺</h1><p>步骤：</p><ol><li>细化需求和估算</li><li>创建用户故事</li><li>创建Product Backlog</li><li>发布计划</li><li>冲刺：冲刺计划会议、创建Sprint Backlog、燃尽初始图、 冲刺计划</li></ol><h2 id="细化需求和估算"><a href="#细化需求和估算" class="headerlink" title="细化需求和估算"></a>细化需求和估算</h2><p>分析需求主题的特性，即拆分为具有若干<font color="red">特性</font>的需求</p><p>特性可能包含有一些<font color="red">史诗故事</font>，即包含了若干个单一行为的活动群</p><font color="red">用户故事</font>：单一行为的需求，可 以在冲刺中立即实现的活动<font color="red">任务</font>：将用户故事拆分为任务， 可以分配给团队成员的工作## 发布计划发布：指包含最小可上市的特征集发布计划：确认团队能够行动的并推出最迫切产品的日期product owner 确定发布目标和发布日期发布计划的两项关键活动（团队成员共同完成）：1、从产品待办列表（Product backlog）中选择优先级高的用户故事2、制定发布计划：目标、日期团队所有成员**承诺发布计划**## 冲刺-   指一次迭代，并提交能够正常工作的产品-   一次冲刺的工作：    1.  开始时的冲刺计划    2.  每日例会    3.  开发时间--冲刺的主体    4.  结束时的冲刺评审和冲刺回顾-   只为当前的冲刺选择用户故事## 冲刺中的敏捷角色冲刺阶段，敏捷角色每天的任务1.  **开发团队**    • 完成可交付的产品2.  **产品负责人**    • 审核产品待办列表和冲刺计划    • 解决开发中的技术问题    • 验证每天的测试结果    • 监督指导持续集成的工作3.  **Scrum主管**    • 每日例会    • 解决遇到的非技术困难，保护开发团队不受外部干扰    • 保持与stakeholders的良好沟通，建立好的人际关系### 冲刺计划会议-   在本次冲刺的第一天召开冲刺计划会议-   参加者：product owner、开发团队、scrum 主管、客户-   主要工作：    -   制定冲刺目标并选择优先级高的用户故事    -   创建Sprint backlog，即分解开发任务-   会议时长;    -   冲刺为1周：开会2小时    -   冲刺为2周：开会4小时    -   冲刺为3周：开会6小时    -   冲刺为4周：开会8小时## 燃尽图（展示了一个冲刺中每天的剩余工作量）燃尽图须体现Sprint Backlog完成进展，即围绕Sprint Backlog的任务燃尽图与开发人员数量、周期、任务数量和时数等有关燃尽图的时数（纵坐标）不包含冲刺的计划、评审和回顾时间![13](http://sshpark.github.io/images/15774111009264)## 任务板-   每个任务做在一个便利贴上，做成一个任务板-   将任务分为4组：**待办；正进行；待验收；已完工**-   用移动便利贴展示冲刺进度，实物变化的视觉更真实-   将任务板放在醒目的位置上，以便每个人都能容易地看到# 冲刺计划示例![26](http://sshpark.github.io/images/15774111011896)# 创建可交付功能冲刺中日常工作的目标是以可交付的形式创建产品的可交付功能。冲刺开发中主要的**三个活动**：-   **细化**    <img src="http://sshpark.github.io/images/15774111014817" alt="15" style="zoom:33%;" />-   **开发**    <img src="http://sshpark.github.io/images/15774111023936" alt="16" style="zoom:33%;" />-   **验证**<img src="http://sshpark.github.io/images/15774111033650" alt="17" style="zoom:33%;" />## 完成的定义![18](http://sshpark.github.io/images/15774111087314)## 完成标准<font color="blue">完成标准确保开发团队每一步前进都奠定在坚实的质量基础之上</font><p>例如：完成的定义 1.编码完成；2.代码评审完成；3.单元测试Bug数小于三个；4.集成完毕；5.文档工作完毕</p><h1 id="敏捷工程实践"><a href="#敏捷工程实践" class="headerlink" title="敏捷工程实践"></a>敏捷工程实践</h1><h2 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h2><p>两位程序员在一台电脑前工作，一个负责敲入代 码，而另外一个实时检查每一行敲入的代码</p><p>结对编程的好处</p><ul><li>有助于提升代码设计质量</li><li>研究表明结对生产率比两个单人总和低 15%，但缺陷数少 15%，考虑修改缺陷工作量和时间都比初始<br>编程大几倍，所以结对编程总体效率更高（source: The Economist）</li><li>结对编程能够大幅促进团队能力提升和知识传播</li></ul><h2 id="持续集成（CI）"><a href="#持续集成（CI）" class="headerlink" title="持续集成（CI）"></a>持续集成（CI）</h2><p>持续集成（CI）是一项软件开发实践，其中团队的成员<strong>经常集成</strong>他们的工作，通常每人每天至少集成一次，每次集成通过自动化构建完成。</p><p>持续集成<strong>提供产品质量的快速反馈</strong>，保证随时拥有可工作的软件</p><h2 id="测试驱动开发（TDD）"><a href="#测试驱动开发（TDD）" class="headerlink" title="测试驱动开发（TDD）"></a>测试驱动开发（TDD）</h2><ul><li>TDD以测试作为编程的中心，要求在编写任何代码之前，首先<strong>编写定义代码功能的测试用例</strong>，编写的代码要通过用例，并不断进行重构优化</li><li>TDD要求测试可以完全自动化运行</li></ul><font color="red">测试驱动开发保证代码整洁可用（Clean code that works）</font><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p>是改善既有代码的设计，由Martin Fowler提出</p><p>重构可以弥补设计的不足</p><p>简单设计&gt;&gt;测试用例&gt;&gt;实现再说&gt;&gt;（重构&gt;&gt;回归测试）</p><h1 id="冲刺中Scrum-主管的工作—识别障碍"><a href="#冲刺中Scrum-主管的工作—识别障碍" class="headerlink" title="冲刺中Scrum 主管的工作—识别障碍"></a>冲刺中Scrum 主管的工作—识别障碍</h1><p>障碍：基本上，任何阻止团队正常工作的，都可称之为障碍</p><ul><li>每日例会可以汇报障碍</li><li>可能的障碍，如：<ol><li>无法访问信息系统</li><li>所需要的信息不能及时提供或者提供的不正确，如界面规格或者其它软件模块不到位或不正确</li><li>开发环境或者原型系统出现问题</li><li>其他的任务分配：培训，售前支持</li><li>缺乏必要的信息或者相应的知识</li></ol></li><li>对于团队提出的各项障碍，Scrum主管要以列表形式进行记录</li></ul><h2 id="谁来清除"><a href="#谁来清除" class="headerlink" title="谁来清除"></a>谁来清除</h2><ul><li>所有人</li><li>scrum 主管负责确定是否已经清除，不一定亲自清除</li></ul><h1 id="展示工作和集中反馈"><a href="#展示工作和集中反馈" class="headerlink" title="展示工作和集中反馈"></a>展示工作和集中反馈</h1><p>冲刺结束的两个会议</p><ul><li>冲刺评审：由产品负责人向用户代表和干系人展示用户故事<strong>（展示工作、收集反馈）</strong></li><li>冲刺回顾：开发团队、产品负责人、scrum主管一起回顾本次冲刺<strong>（评审冲刺 、改进流程）</strong></li></ul><h2 id="冲刺评审"><a href="#冲刺评审" class="headerlink" title="冲刺评审"></a>冲刺评审</h2><ul><li>通过演示可交付的功能可以确认项目的进度，具有真实性</li><li>能尽早的获得用户对产品的反馈，使产品更加贴近客户需求</li></ul><h2 id="冲刺回顾"><a href="#冲刺回顾" class="headerlink" title="冲刺回顾"></a>冲刺回顾</h2><ul><li>激励团队成员</li><li>帮助团队挖掘优秀经验并继承</li><li>避免团队犯重复的错误</li><li>营造团队自主改进的氛围</li></ul><h1 id="冲刺结束—两类冲刺"><a href="#冲刺结束—两类冲刺" class="headerlink" title="冲刺结束—两类冲刺"></a>冲刺结束—两类冲刺</h1><ul><li>产品冲刺：若本次冲刺不产生发布产品，则冲刺结束，准备进入下一次冲刺</li><li>发布冲刺：若本次冲刺产生发布产品，则需完成发布冲刺的活动</li></ul><h1 id="发布准备"><a href="#发布准备" class="headerlink" title="发布准备"></a>发布准备</h1><ul><li>准备部署产品 – 发布冲刺</li><li>让组织为产品发布做好准备</li><li>让市场为产品发布做好准备</li></ul><h2 id="内部准备"><a href="#内部准备" class="headerlink" title="内部准备"></a>内部准备</h2><ul><li>除了产品生产部门，企业的其他组织部门要为产品发布做好准备</li><li>产品负责人和Scrum主管要准备一个发布冲刺待办列表</li><li>识别和确定完成发布活动的干系人</li><li>为发布产品的评审会准备正式的PPT，解释产品的背景、目 标、价值，确保干系人充分理解产品和产品客户</li><li>评审会应该由<font color="red">市场部或运营部</font>主持，产品负责人只是负责冲刺发布任务的汇报</li></ul><h2 id="外部准备"><a href="#外部准备" class="headerlink" title="外部准备"></a>外部准备</h2><ul><li>营销支持—确定产品推广、品牌营销的时机</li><li>客户测试—运营和市场要把客户反馈转化为产品推广的依据</li><li>营销物料—产品推广文案、新闻发布会、产品包装等</li><li>支持渠道—所有类型客户到技术支持部的渠道要畅通</li></ul><h1 id="在企业中实施敏捷"><a href="#在企业中实施敏捷" class="headerlink" title="在企业中实施敏捷"></a>在企业中实施敏捷</h1><p><strong>重要的：</strong>在企业的级别上，统筹组织，系统地制定敏捷实施方案软件开发项目组是逐步地实施敏捷管理方法</p><p>你到了企业：</p><p>可以成为敏捷导师，帮助企业建立敏捷实施方案</p><p>或快速地熟悉企业目前的敏捷实施方案，参与到敏捷项目管理团队</p><p><strong>步骤：</strong></p><ol><li>制定实施策略</li><li>构建意识，培养热情</li><li>实施团队转型</li><li>确定实验的项目</li><li>确定成功的标准：时间、成本、质量、风险、变更、交付的成果</li><li>培训计划与实施</li><li>总结和改进</li><li>推广</li></ol><h1 id="实现敏捷转型的系统工程"><a href="#实现敏捷转型的系统工程" class="headerlink" title="实现敏捷转型的系统工程"></a>实现敏捷转型的系统工程</h1><p>敏捷转型覆盖7个方面：实践、组织、过程、绩效考核、管控、文化、技术和业务调整</p><p>敏捷在敏捷转型不同阶段，敏捷转型框架的7个方面引入的优先级不一 样，初期以实践为主</p><p>实践 (Practices)：<strong>团队根据自身情况选择合适的实践应用</strong></p><p>组织(Organization)：<strong>组织适应产品业务架构、产品管理办公室(PMO)、测试、产品管理等</strong></p><p>过程(Process)：<strong>流程、敏捷项目管理策略等，由企业管理者和敏捷导师共同制定</strong></p><p>绩效度量（Performance)：<strong>业务价值、质量、过程改进</strong></p><p>管理监控(Governance)：<strong>包括管控点设置，如投资评审和风险评估等</strong></p><p>文化理念(Culture)：<strong>从命令控制式的管理文化转向领导协作的文化，加强透明性和实际性</strong></p><p>技术和业务调整(Alignment)：<strong>业务策略、IT策略、企业/产品架构、产品组合管理、合同、能力规划等调整</strong></p><h1 id="企业中如何组织实施敏捷项目管理"><a href="#企业中如何组织实施敏捷项目管理" class="headerlink" title="企业中如何组织实施敏捷项目管理"></a>企业中如何组织实施敏捷项目管理</h1><ul><li>组织与个人的承诺</li><li>选择正确的项目团队成员：</li><li>PO：业务能力强，做事果断；</li><li>Scrum主管：有影响力，善于沟通；</li><li>开发成员：愿意合作的</li><li>创建合适敏捷的环境：团队要整齐，要及时调整</li><li>持续地支持敏捷：选择合适的项目，拥有一位敏捷导师</li></ul><h1 id="其他敏捷开发方法"><a href="#其他敏捷开发方法" class="headerlink" title="其他敏捷开发方法"></a>其他敏捷开发方法</h1><p><img src="http://sshpark.github.io/images/15774111093332" alt="21"></p><h3 id="XP"><a href="#XP" class="headerlink" title="XP"></a>XP</h3><p>要求客户与开 发人员最好以side-by-side的方式一起工作</p><h3 id="精益软件开发方法"><a href="#精益软件开发方法" class="headerlink" title="精益软件开发方法"></a>精益软件开发方法</h3><p>七条原则：</p><ol><li>消除浪费</li><li>增强学习</li><li>尽量延迟决定</li><li>尽快发布</li><li>下放权力</li><li>嵌入质量</li><li>全局优化</li></ol><p>对应有精益用户体验</p><h3 id="自适应软件开发方法（ASD）"><a href="#自适应软件开发方法（ASD）" class="headerlink" title="自适应软件开发方法（ASD）"></a>自适应软件开发方法（ASD）</h3><p>ASD是一种方法论，没有很多具体的实践做法，主要为ASD的重要性提供根本的基础。</p><p>是从更高的组织和管理层次阐述开发方法为什么要具备适应性。</p><h3 id="特性驱动开发方法（FDD）"><a href="#特性驱动开发方法（FDD）" class="headerlink" title="特性驱动开发方法（FDD）"></a>特性驱动开发方法（FDD）</h3><ul><li>是一套针对中小型软件开发项目的开发模式</li><li>是一个模型驱动的快速迭代开发过程（从需求特征的模型开始）</li><li>强调简化、实用、 易于被开发团队接受的理念</li><li>适用于需求经常变动的项目</li></ul><h2 id="水晶族方法"><a href="#水晶族方法" class="headerlink" title="水晶族方法"></a>水晶族方法</h2><p>具有灵活、执行不严格、全透明的工作方式，一般团队人数少于6人</p><p>是个族系列，对不同类型的项目可以采用不同的实践方法</p><p>水晶族系列没有XP方法的效率高，但有适合的项目和人员接受并遵循该方法</p><p>水晶族系列方法的七大体系特征：</p><ol><li>经常交付</li><li>反思改进</li><li>渗透式交流</li><li>个人安全</li><li>焦点</li><li>与专家用户建立方便的联系</li><li>配有自动测试、配置管理和经常集成功能的技术环境</li></ol><h2 id="动态系统开发方法"><a href="#动态系统开发方法" class="headerlink" title="动态系统开发方法"></a>动态系统开发方法</h2><p>倡导以业务为核心，快速而有效地进行系统开发</p><p>适用于系统升级的二次开发</p><p>看成一种控制框架，其重点在于快速交付并补充如何应用这些控制的指导原则</p><h2 id="敏捷统一过程"><a href="#敏捷统一过程" class="headerlink" title="敏捷统一过程"></a>敏捷统一过程</h2><p>由Craig Larman提出，是轻量型RUP，是过程的框架，可以包容许多不同类型的过程</p><p>以敏捷型方式使用RUP，其观点是：目前如此众多敏捷型方法，都不过是在接受被视为 RUP 的主流OO开发方法而已</p><h1 id="敏捷度量"><a href="#敏捷度量" class="headerlink" title="敏捷度量"></a>敏捷度量</h1><p>敏捷三角形</p><p><img src="http://sshpark.github.io/images/15774111102368" alt="27" style="zoom:50%;" /></p><ul><li>项目是否成功取决于主观的判断</li><li>不能度量就不能管理</li></ul><p>Value度量的组成</p><p><img src="http://sshpark.github.io/images/15774111104360" alt="28" style="zoom:33%;" /></p><h1 id="Scrum-Of-Scrums"><a href="#Scrum-Of-Scrums" class="headerlink" title="Scrum Of Scrums"></a>Scrum Of Scrums</h1><ul><li>把Scrum扩展到大型项目团队的一个实践</li><li>Scrum of Scrums可以是多层次的</li><li>是跨团队的沟通与交流</li><li>由各个Scrum团队的代表参加Scrum of<br>Scrums会议</li><li>会议也采用固定的频率，如每周2次</li><li>会议时长也控制在15-30分钟</li><li>会议中提出的问题要及时处理</li></ul><h1 id="！敏捷项目管理的十大关键测量指标"><a href="#！敏捷项目管理的十大关键测量指标" class="headerlink" title="！敏捷项目管理的十大关键测量指标"></a>！敏捷项目管理的十大关键测量指标</h1><p><img src="http://sshpark.github.io/images/15774111107211" alt="22" style="zoom: 33%;" /></p><h1 id="敏捷项目管理的十大好处"><a href="#敏捷项目管理的十大好处" class="headerlink" title="敏捷项目管理的十大好处"></a>敏捷项目管理的十大好处</h1><p><img src="http://sshpark.github.io/images/15774111112271" alt="23" style="zoom: 33%;" /></p><h1 id="额外的一些东西"><a href="#额外的一些东西" class="headerlink" title="额外的一些东西"></a>额外的一些东西</h1><h2 id="经验性方式的三大支柱"><a href="#经验性方式的三大支柱" class="headerlink" title="经验性方式的三大支柱"></a>经验性方式的三大支柱</h2><p>可见性、检查及适应</p><h2 id="全天的工作"><a href="#全天的工作" class="headerlink" title="全天的工作"></a>全天的工作</h2><ol><li><p>计划每天的工作</p><p>每日例会（标注已完成的任务）、发现问题和难点、计划当天的工作</p><p>目的：沟通交流，不是解决问题！有问题可以在另外的专题会上解决</p><p>由scrum master主持，每位成员轮流回答以下问题</p><ul><li>昨天我完成了什么工作？</li><li>今天我打算做什么？</li><li>我在工作中遇到了什么困难？</li></ul></li><li><p>跟踪每天的进展，工具：燃尽图、任务板</p></li><li><p>开发并测试每天的工作</p></li><li><p>结束一天的工作</p></li></ol><h2 id="结束一天的工作"><a href="#结束一天的工作" class="headerlink" title="结束一天的工作"></a>结束一天的工作</h2><p>• 更新sprint backlog的任务状态<br>• 根据燃尽图的剩余工作量，调整：<br>• 任务（移除/增加）<br>• 人员安排（增加开发团队人员/任务再分配）<br>• 时间安排（是否需要加班?）<br>• 更新燃尽图（可以用两个燃尽图：工作人时数/任务点数）<br>• 产品负责人更新任务板便利贴的位置，如：待验收-&gt;已完成<br>• Scrum主管检查燃尽图和Sprint backlog，及时发现可能的风险</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="http://sshpark.github.io/images/15774111115242" alt="19" style="zoom:33%;" /></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><img src="http://sshpark.github.io/images/15774111170787" alt="20" style="zoom:33%;" /></p><h2 id="product-backlog"><a href="#product-backlog" class="headerlink" title="product backlog"></a>product backlog</h2><p><img src="http://sshpark.github.io/images/15774110950501" alt=""></p><ul><li>是 product owner 编写的需求列表</li><li>优先级可能会变化</li><li>列表内容可能会变化</li></ul>]]></content>
    
    <summary type="html">
    
      敏捷项目管理的一些知识点，内容来自课堂 PPT。
    
    </summary>
    
    
    
      <category term="学习笔记" scheme="http://sshpark.com.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>torch.distributed 中 Collective functions 的使用方式</title>
    <link href="http://sshpark.com.cn/2019/12/20/torch-distributed-%E4%B8%ADCollective-functions-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://sshpark.com.cn/2019/12/20/torch-distributed-%E4%B8%ADCollective-functions-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</id>
    <published>2019-12-20T12:58:13.000Z</published>
    <updated>2021-05-25T11:21:27.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  <code>Pytorch</code> 中的分布式包（<strong>torch.distributed</strong>）可以帮助研究人员或者从业人员轻松地跨进程或在计算机集群中实现并行计算。</p><p>  <code>torch.distributed</code> 支持三种后端，分别是 <code>gloo, nccl</code> 以及 <code>mpi</code>。 不同的后端对应的功能不一样，可以根据实际情况选择。</p></blockquote><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>为了展示这几个函数的使用，我们这里通过 docker 创建三个容器模拟真实物理机，镜像使用的是 <strong>pytorch/pytorch</strong>。</p><p>使用下面命令创建三个 docker 容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name device1 -v [这里填写项目的绝对路径]:/root pytorch/pytorch</span><br><span class="line"></span><br><span class="line">docker run -it --name device2 -v [这里填写项目的绝对路径]:/root pytorch/pytorch</span><br><span class="line"></span><br><span class="line">docker run -it --name device3 -v [这里填写项目的绝对路径]:/root pytorch/pytorch</span><br></pre></td></tr></table></figure><p>这里需要开三个终端，每个终端对应一个容器。<code>-v</code> 参数是为了将本地目录映射到容器中，方便管理文件。如下图所示，我们创建了三个容器。</p><p><img src="http://sshpark.github.io/images/20191219212717.png" alt="三个容器"></p><p>然后需要获取三个容器的 ip 地址，使用下面的命令可以获取相应容器的 ip 地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器ID | grep IPAddress</span><br></pre></td></tr></table></figure><p>在我的电脑上<code>device1,device2,device3</code>对应的 ip 地址分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">172.17.0.2</span><br><span class="line">172.17.0.3</span><br><span class="line">172.17.0.4</span><br></pre></td></tr></table></figure><p>我们指定 ip 地址为 <code>172.17.0.2</code> 的容器为 <code>rank=0</code>，初始化方法使用 tcp，main 函数代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'--rank'</span>, type=int, default=<span class="number">0</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--world_size'</span>, type=int, default=<span class="number">2</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    dist.init_process_group(backend=<span class="string">'gloo'</span>, \</span><br><span class="line">        init_method=<span class="string">'tcp://172.17.0.2:8991'</span>, \</span><br><span class="line">        rank=args.rank, \</span><br><span class="line">        world_size=args.world_size)</span><br><span class="line">    run(dist.get_rank())</span><br></pre></td></tr></table></figure><h1 id="Collective-functions"><a href="#Collective-functions" class="headerlink" title="Collective functions"></a>Collective functions</h1><p>在 <code>pytorch</code> 中目前有六种 <code>Collective functions</code> ，分别是 <code>Scatter,Gather,Reduce,All-Reduce,Broadcast,All-Gather</code>。来看看<a href="https://pytorch.org/tutorials/intermediate/dist_tuto.html" target="_blank" rel="noopener">官网</a>的一张图就可以直观的认识到这几个函数的作用。</p><p><img src="http://sshpark.github.io/images/20191219211337.png" alt="Collective functions"></p><h2 id="scatter"><a href="#scatter" class="headerlink" title="scatter"></a>scatter</h2><p><code>torch.distributed.scatter(tensor, scatter_list=None, src=0, group=\&lt;object object\&gt;, async_op=False)</code></p><p>这个函数的功能是将 <code>scatter_list</code> 列表中的第 <code>i</code> 个张量（tensor）发送到第 <code>i</code> 个进程中。代码如下所示：</p><font color="red">注意：如果是接收方，那么scatter_list=[]</font><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist</span><br><span class="line"></span><br><span class="line">weight = torch.zeros(<span class="number">1</span>)</span><br><span class="line">scatter_list = [torch.randn_like(weight) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(rank)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    数据分发</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">        dist.scatter(weight, scatter_list, <span class="number">0</span>)</span><br><span class="line">        print(scatter_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dist.scatter(weight, [], <span class="number">0</span>)</span><br><span class="line">        print(<span class="string">'rank &#123;&#125; receiving data &#123;&#125; from -\</span></span><br><span class="line"><span class="string">            rank0'</span>.format( rank, weight ))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    parser.add_argument(<span class="string">'--rank'</span>, type=int, default=<span class="number">0</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'--world_size'</span>, type=int, default=<span class="number">2</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    dist.init_process_group(backend=<span class="string">'gloo'</span>, \</span><br><span class="line">        init_method=<span class="string">'tcp://172.17.0.2:8991'</span>, \</span><br><span class="line">        rank=args.rank, \</span><br><span class="line">        world_size=args.world_size)</span><br><span class="line">    run(dist.get_rank())</span><br></pre></td></tr></table></figure><p>device1运行指令 <code>python test.py --rank 0 --world_size 3</code>，device2 运行命令 <code>python test.py --rank 1 --world_size 3</code>，device3 运行命令 <code>python test.py --rank 2 --world_size 3</code>。结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[tensor([-1.2237]), tensor([-0.0276]), tensor([-0.9581])]</span><br><span class="line">rank 1 receiving data tensor([-0.0276]) from rank0</span><br><span class="line">rank 2 receiving data tensor([-0.9581]) from rank0</span><br></pre></td></tr></table></figure><h2 id="gather"><a href="#gather" class="headerlink" title="gather"></a>gather</h2><p><code>torch.distributed.gather(tensor, gather_list=None, dst=0, group=\&lt;object object\&gt;, async_op=False)</code></p><p>将所有进程的 tensor 值拷贝到 rank=dst 的进程中。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist</span><br><span class="line">weight = torch.zeros(<span class="number">1</span>)</span><br><span class="line">gather_list = [torch.ones_like(weight) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(rank)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> weight</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">        dist.gather(weight, gather_list, <span class="number">0</span>)</span><br><span class="line">        print(gather_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        weight = torch.randn(<span class="number">1</span>)</span><br><span class="line">        dist.gather(weight)</span><br><span class="line">        print(<span class="string">'rank &#123;&#125; is sending data &#123;&#125; to rank 0'</span>\</span><br><span class="line">            .format( rank, weight ))</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[tensor([0.]), tensor([0.5088]), tensor([1.3696])]</span><br><span class="line">rank 1 is sending data tensor([0.5088]) to rank 0</span><br><span class="line">rank 2 is sending data tensor([1.3696]) to rank 0</span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p><code>torch.distributed.reduce(tensor, dst, op=ReduceOp.SUM, group=\&lt;object object\&gt;, async_op=False)</code></p><p>将 tensor 发送到 dst 并执行相应的 op 操作。</p><p>其中的 op 操作有：</p><ul><li>SUM</li><li>PRODUCT</li><li>MIN</li><li>MAX</li><li>BAND</li><li>BOR</li><li>BXOR</li></ul><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> torch.distributed <span class="keyword">as</span> dist</span><br><span class="line">weight = torch.zeros(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gather_list = [torch.ones_like(weight) for i in range(3)]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(rank)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> weight</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">        dist.reduce(weight, <span class="number">0</span>, op=dist.ReduceOp.MAX)</span><br><span class="line">        print(weight)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        weight = torch.randn(<span class="number">1</span>)</span><br><span class="line">        dist.reduce(weight, <span class="number">0</span>)</span><br><span class="line">        print(<span class="string">'rank &#123;&#125; sending data &#123;&#125; to rank 0'</span>\</span><br><span class="line">            .format( rank, weight ))</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tensor([0.7700])</span><br><span class="line">rank 1 sending data tensor([0.7700]) to rank 0</span><br><span class="line">rank 2 sending data tensor([-0.4824]) to rank 0</span><br></pre></td></tr></table></figure><p><br></p><p>后面的就不写样例展示了，知道了函数的功能之后相信大家都能够写得出来。</p><p><br></p><h2 id="Broadcast"><a href="#Broadcast" class="headerlink" title="Broadcast"></a>Broadcast</h2><p><code>torch.distributed.broadcast(tensor, src, group=\&lt;object object\&gt;, async_op=False)</code></p><p>将 tensor 从 src 发送到所有的进程</p><h2 id="All-Reduce"><a href="#All-Reduce" class="headerlink" title="All-Reduce"></a>All-Reduce</h2><p><code>torch.distributed.all_reduce(tensor, op=ReduceOp.SUM, group=\&lt;object object\&gt;, async_op=False)</code></p><p>跟 reduce 的功能一样，只不过它是所有的进程都会进行 reduce 操作。</p><h2 id="All-Gather"><a href="#All-Gather" class="headerlink" title="All-Gather"></a>All-Gather</h2><p><code>torch.distributed.all_gather(tensor_list, tensor, group=\&lt;object object\&gt;, async_op=False)</code></p><p>跟 gather 的功能一样，只不过它是所有的进程都会进行 gather 操作。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>其实代码可以再简洁点，可以使用 <code>torch.multiprocessing</code> 包，就不需要使用 docker 模拟了。然后 main 函数改为:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    mp.spawn(f, nprocs=<span class="number">3</span>, args=())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用 pytorch 中的分布式包可以轻松的实现并行计算，但是在官方文档中没有 Collective functions 的示例代码，而且网络上对这方面的介绍也比较少。对并行计算不熟悉的人使用起来可能会有点小问题，因此这里通过简单的代码展示了如何去使用 Collective functions。
    
    </summary>
    
    
    
      <category term="PyTorch" scheme="http://sshpark.com.cn/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 167</title>
    <link href="http://sshpark.com.cn/2019/12/17/LeetCode-Weekly-Contest-167/"/>
    <id>http://sshpark.com.cn/2019/12/17/LeetCode-Weekly-Contest-167/</id>
    <published>2019-12-17T12:20:24.000Z</published>
    <updated>2021-05-25T11:21:27.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1290-二进制链表转整数"><a href="#1290-二进制链表转整数" class="headerlink" title="1290. 二进制链表转整数"></a><a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">1290. 二进制链表转整数</a></h2><p>给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。</p><p>请你返回该链表所表示数字的 十进制值 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,0,1]</span><br><span class="line">输出：5</span><br><span class="line">解释：二进制数 (101) 转化为十进制数 (5)</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>先求这个链表有多长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">35</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            a[cnt++] = head-&gt;val;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">            res += (<span class="number">1</span>&lt;&lt;(cnt-i<span class="number">-1</span>))*a[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1291-顺次数"><a href="#1291-顺次数" class="headerlink" title="1291. 顺次数"></a><a href="https://leetcode-cn.com/problems/sequential-digits/" target="_blank" rel="noopener">1291. 顺次数</a></h2><p>我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。</p><p>请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出：low &#x3D; 100, high &#x3D; 300</span><br><span class="line">输出：[123,234]</span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>找规律或者打表都可以。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequentialDigits(<span class="keyword">int</span> low, <span class="keyword">int</span> high) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, h;</span><br><span class="line">        <span class="keyword">int</span> templ = low, temph = high;</span><br><span class="line">        l = h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (templ) &#123;</span><br><span class="line">            l++;</span><br><span class="line">            templ /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (temph) &#123;</span><br><span class="line">            h++;</span><br><span class="line">            temph /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= h; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> s = <span class="number">0</span>, t = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                s += j*t;</span><br><span class="line">                cnt += t;</span><br><span class="line">                t *= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>-i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s &gt;= low &amp;&amp; s &lt;= high)</span><br><span class="line">                    ans.push_back((<span class="keyword">int</span>)s);</span><br><span class="line">                s += cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1292-元素和小于等于阈值的正方形的最大边长"><a href="#1292-元素和小于等于阈值的正方形的最大边长" class="headerlink" title="1292. 元素和小于等于阈值的正方形的最大边长"></a><a href="https://leetcode-cn.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/" target="_blank" rel="noopener">1292. 元素和小于等于阈值的正方形的最大边长</a></h2><p>给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。</p><p>请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat &#x3D; [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold &#x3D; 4</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>二维前缀和预处理，然后枚举正方形边长，判断是否符合，时间复杂度 $O(n^3)$</p><p>优化：</p><p>枚举边长这一步可以使用二分法，因为正方形内的和随边长的增加而增大，满足二分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSideLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = mat.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> psum[<span class="number">305</span>][<span class="number">305</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(psum, <span class="number">0</span>, <span class="keyword">sizeof</span> psum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)    </span><br><span class="line">                psum[i][j] = psum[i][j<span class="number">-1</span>]+psum[i<span class="number">-1</span>][j]-psum[i<span class="number">-1</span>][j<span class="number">-1</span>]+mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = min(n, m);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= len; k++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i+k<span class="number">-1</span> &lt;= n; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j+k<span class="number">-1</span> &lt;= m; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ex = i+k<span class="number">-1</span>, ey = j+k<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (psum[ex][ey]-psum[ex][j<span class="number">-1</span>]-psum[i<span class="number">-1</span>][ey]+psum[i<span class="number">-1</span>][j<span class="number">-1</span>] &lt;= threshold)</span><br><span class="line">                    ans = max(k, ans);</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1293-网格中的最短路径"><a href="#1293-网格中的最短路径" class="headerlink" title="1293. 网格中的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/" target="_blank" rel="noopener">1293. 网格中的最短路径</a></h2><p>给你一个 <code>m * n</code> 的网格，其中每个单元格不是 <code>0</code>（空）就是 <code>1</code>（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。</p><p>如果您 最多 可以消除 k 个障碍物，请找出从左上角 <code>(0, 0)</code> 到右下角 <code>(m-1, n-1)</code> 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 -1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入： </span><br><span class="line">grid &#x3D; </span><br><span class="line">[[0,0,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [0,1,1],</span><br><span class="line"> [0,0,0]], </span><br><span class="line">k &#x3D; 1</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">不消除任何障碍的最短路径是 10。</span><br><span class="line">消除位置 (3,2) 处的障碍后，最短路径是 6 。该路径是 (0,0) -&gt; (0,1) -&gt; (0,2) -&gt; (1,2) -&gt; (2,2) -&gt; (3,2) -&gt; (4,2).</span><br></pre></td></tr></table></figure><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>在普通的 <code>BFS</code> 上多加一个状态记录<strong>当前最多还可以消除</strong>几个障碍物。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y, step, k;</span><br><span class="line">        node() &#123;x = y = step = k = <span class="number">0</span>;&#125;</span><br><span class="line">        node(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> step, <span class="keyword">int</span> k): x(x), y(y), step(step), k(k) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">bool</span> vis[n+<span class="number">1</span>][m+<span class="number">1</span>][k+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line">        node s;</span><br><span class="line">        s.k = k;</span><br><span class="line">        q.push(s);</span><br><span class="line">        vis[<span class="number">0</span>][<span class="number">0</span>][k] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            node top = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (top.x == n<span class="number">-1</span> &amp;&amp; top.y == m<span class="number">-1</span>) <span class="keyword">return</span> top.step;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = top.x+dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> ny = top.y+dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span></span><br><span class="line">                || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[nx][ny]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top.k &amp;&amp; !vis[nx][ny][top.k<span class="number">-1</span>]) &#123;</span><br><span class="line">                        q.push(node(nx, ny, top.step+<span class="number">1</span>, top.k<span class="number">-1</span>));</span><br><span class="line">                        vis[nx][ny][top.k<span class="number">-1</span>] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[nx][ny][top.k]) &#123;</span><br><span class="line">                        q.push(node(nx, ny, top.step+<span class="number">1</span>, top.k));</span><br><span class="line">                        vis[nx][ny][top.k] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      leetcode 第 167 场周赛
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://sshpark.com.cn/tags/LeetCode/"/>
    
      <category term="bfs" scheme="http://sshpark.com.cn/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>[论文笔记] Edge-Assisted Hierarchical Federated Learning withNon-IID Data</title>
    <link href="http://sshpark.com.cn/2019/10/31/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Edge-Assisted-Hierarchical-Federated-Learning-withNon-IID-Data/"/>
    <id>http://sshpark.com.cn/2019/10/31/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0-Edge-Assisted-Hierarchical-Federated-Learning-withNon-IID-Data/</id>
    <published>2019-10-31T09:18:50.000Z</published>
    <updated>2021-05-25T11:21:27.964Z</updated>
    
    <content type="html"><![CDATA[<p>提出了一种分层的联邦学习以及对应算法（HierFAVG）降低<strong>通信延时</strong>问题，与传统的 <strong>FAVG(Federated Averaging)</strong> 做对比。</p><a id="more"></a><h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://arxiv.org/pdf/1905.06641.pdf" target="_blank" rel="noopener">Edge-Assisted Hierarchical Federated Learning withNon-IID Data</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>将 ML 或 DL 模型应用在边缘设备上是一个革命性的突破。然而，传统的模型训练是在计算中心完成的，近几年出于隐私保护问题，用户数据将不会上传至计算中心，数据保留在用户手中。在不上传数据的情况下，FL （联邦学习）提出了让各个设备协同训练一个<strong>共享模型</strong>，然后上传模型的更新信息到云中心进行模型聚合。但是，这种做法在通信消耗上出现了瓶颈。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>分层结构如下：</p><p><img src="http://sshpark.github.io/images/20191031004503.png" width="700px" /></p><p>客户端的更新参数不是直接发送至<strong>云中心</strong>，而是发送至<strong>边缘服务器</strong>，然后<strong>边缘服务器</strong>再发送至云中心。</p><p>原因如下：</p><ol><li>云中心比边缘服务器能够处理更多的用户连接，能够处理大量数据进行模型聚合。</li><li>客户端与边缘服务器的通信延时更低。</li></ol><h2 id="HierFAVG-算法过程"><a href="#HierFAVG-算法过程" class="headerlink" title="HierFAVG 算法过程"></a>HierFAVG 算法过程</h2><p>客户端每经过 $\tau_1$ 轮的更新就在边缘服务器上进行模型聚合操作，边缘服务器每经过 $\tau_2$ 轮的聚合就在云中心进行模型聚合。也就是说每经过 $\tau_1 \tau_2$ 轮的更新就与云中心通信。</p><p>我们记 $\mathcal{w}_i^l(t)$ 为第 t 轮本地更新的模型参数，那么有：</p><p><img src="http://sshpark.github.io/images/20191031005851.png" width="500px" /></p><p>算法过程如下：</p><p><img src="http://sshpark.github.io/images/20191031192459.png" width="500px" /></p><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>$T_\alpha$ 表示达到准确率 $\alpha$ 需要的时间</p><p>$N_\alpha$ 表示达到准确率 $\alpha$ 需要的通信次数</p><p><br></p><p><img src="http://sshpark.github.io/images/20191031194331.png" width="500px" /></p><p>如上表所示，当 $\tau_1 \tau_2$ 固定为 60 的时候，无论是 Edge-IID 还是 Edge-NIID，与云中心的通信次数都<strong>随着 $\tau_1$ 的减少而减少</strong>。这是因为<strong>随着 $\tau_1$ 的减少</strong>模型的收敛速度更快了，如图1所示。</p><p>同时实验也表明了通过适当的增加 $\tau_2$ 可以降低与云中心的通信次数。但是这对于NIID不是那么使用，当 $\tau_1=60, \tau_2 = 64$ 的时候，模型无法收敛到预期精度。</p><p><img alt="http://sshpark.github.io/images/20191031195551.png" width="500px" /></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章提出了一种分层的联邦学习体系结构，并辅以训练算法 <strong>HierFAVG</strong>。对于两个云模型聚合之间相同数量的本地更新，优先选择较小的边缘聚合间隔 $\tau_1$ 。 此外，当边缘云之间的数据分布为 <strong>IID</strong> 时，可以通过增加 $\tau_2$ 来减少通信开销。 尽管研究表明在选择 $\tau_1, \tau_2$ 值时需要权衡取舍，但仍需进一步研究以充分表征和优化这些关键参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提出了一种分层的联邦学习以及对应算法（HierFAVG）降低&lt;strong&gt;通信延时&lt;/strong&gt;问题，与传统的 &lt;strong&gt;FAVG(Federated Averaging)&lt;/strong&gt; 做对比。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://sshpark.com.cn/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
      <category term="联邦学习" scheme="http://sshpark.com.cn/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="边缘计算" scheme="http://sshpark.com.cn/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
      <category term="Non-IID" scheme="http://sshpark.com.cn/tags/Non-IID/"/>
    
  </entry>
  
  <entry>
    <title>[论文笔记] Gossip Learning</title>
    <link href="http://sshpark.com.cn/2019/10/24/Gossip-Learning/"/>
    <id>http://sshpark.com.cn/2019/10/24/Gossip-Learning/</id>
    <published>2019-10-24T11:59:22.000Z</published>
    <updated>2021-05-25T11:21:28.019Z</updated>
    
    <content type="html"><![CDATA[<p>提出 Gossip Learning，与 Federated Learning 做比较，实验表明使用 Gossip Learning 训练的模型在一定时间过后与Federated Learning 表现相当。</p><a id="more"></a><h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://link.springer.com/chapter/10.1007/978-3-030-22496-7_5" target="_blank" rel="noopener">Hegedűs I, Danner G, Jelasity M. Gossip Learning as a Decentralized Alternative to Federated Learning[C]//IFIP International Conference on Distributed Applications and Interoperable Systems. Springer, Cham, 2019: 74-90.</a></p><p><br></p><h2 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h2><p>传统的 Federated Learning 是 master-worker 架构（master 节点负责模型聚合，worker 是边缘设备，不同于参数服务器架构）</p><p>Gossip Learning 同样主张将数据保留在边缘设备上，但是它没有负责聚合的服务或者任何的中心组成部分，也就是说它是去中心化的。</p><p>文章通过实验表明了这两种方法训练出的模型变现相当，在高压缩率（采样率低）情况下，Gossip Learning 表现更佳。</p><p><br></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><h3 id="Federated-Learning"><a href="#Federated-Learning" class="headerlink" title="Federated Learning"></a>Federated Learning</h3><p>worker 节点训练过程是异步的，master 在给定的时间 $\Delta_f$ 内收集来自 worker 的参数信息，超过 $\Delta_f$ 仍未发送信息的worker 将被抛弃。<strong>算法第 10 行</strong>使用了压缩机制。</p><p>master 节点运行的算法：</p><p><img src="http://sshpark.github.io/images/20191024215805.png" width="500px" /></p><p>worker 节点运行的算法：</p><p><img src="http://sshpark.github.io/images/20191024220506.png" width="500px" /></p><p><br></p><h3 id="Gossip-Learning"><a href="#Gossip-Learning" class="headerlink" title="Gossip Learning"></a>Gossip Learning</h3><p>Gossip Learning 的特点是没有中心节点，每次更新的时候使用一种<strong>采样方式[参考文献 1， 2]</strong>从相邻节点获取模型参数 $w_r$ 并合并到本地模型中，随后使用本地数据 $D_k$ 更新。</p><p><img src="http://sshpark.github.io/images/20191025152405.png" width="500px" /></p><p><br></p><h3 id="模型压缩以及聚合"><a href="#模型压缩以及聚合" class="headerlink" title="模型压缩以及聚合"></a>模型压缩以及聚合</h3><p>模型压缩：</p><ul><li>不压缩</li><li>随机选取大小为 s 的模型参数</li></ul><p><img src="http://sshpark.github.io/images/20191025152637.png" width="500px" /></p><p>模型聚合：</p><ul><li>简单的平均</li><li>基于采样进行聚合</li></ul><p><img src="http://sshpark.github.io/images/20191025152837.png" width="500px" /></p><p>模型参数更新：</p><p><img src="http://sshpark.github.io/images/20191025153254.png" width="500px" /></p><p><br></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>基于不同采样率在 <strong>Spambase Dataset</strong> 上的实验结果。</p><p><img src="http://sshpark.github.io/images/20191025153921.png" width="700px" /></p><p>还有其他实验结果就不一一列举了。</p><p><br></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>文章的目标在模型学习效率上进行对比，在统一分配的情况下，Gossip Learning 和 Federated Learning 效率差不多，在高压缩率下，Gossip Learning 表现更好。</p><p>未来工作的方向是设计一种针对 Gossip Learning 和 Federated Learning 的模型评估，以及更复杂的压缩技术。</p><p><br></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li>Jelasity, M., Voulgaris, S., Guerraoui, R., Kermarrec, A.M., van Steen,  M.: Gossip-based peer sampling. ACM Trans. Comput. Syst. <strong>25</strong>(3), 8 (2007)</li><li>Roverso, R., Dowling, J., Jelasity, M.: Through the wormhole: low cost,  fresh peer sampling for the internet. In: Proceedings of the 13th IEEE  International Conference on Peer-to-Peer Computing (P2P 2013). IEEE  (2013)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提出 Gossip Learning，与 Federated Learning 做比较，实验表明使用 Gossip Learning 训练的模型在一定时间过后与Federated Learning 表现相当。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="论文笔记" scheme="http://sshpark.com.cn/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
      <category term="联邦学习" scheme="http://sshpark.com.cn/tags/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="Gossip Learning" scheme="http://sshpark.com.cn/tags/Gossip-Learning/"/>
    
      <category term="边缘计算" scheme="http://sshpark.com.cn/tags/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>分布式机器学习: 通信机制</title>
    <link href="http://sshpark.com.cn/2019/10/24/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
    <id>http://sshpark.com.cn/2019/10/24/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/</id>
    <published>2019-10-24T01:29:25.000Z</published>
    <updated>2021-05-25T11:21:28.005Z</updated>
    
    <content type="html"><![CDATA[<p><strong>分布式机器学习</strong>与<strong>单机版的机器学习</strong>最大区别在于，它利用了多个工作节点同时训练、相互合作来加速学习过程。既然需要相互合作，那么通信就成为必不可少的环节。不过，分布式系统中的网络传输速度往往受限，导致通信常常成为分布式系统的瓶颈。举一个简单的例子：如果某个任务中计算与通信的时间占比为 1:1, 那么根据<strong>阿姆达尔定律（Amdahl’s law）</strong>，无论使用多少台机器做并行运算，其加速比都不会超过两倍。因此，分布式机器学习的关键是设计通信机制，从而降低通信与计算的时间比例，更加高效地训练出高精度的模型。</p><a id="more"></a><h1 id="一、通信的内容"><a href="#一、通信的内容" class="headerlink" title="一、通信的内容"></a>一、通信的内容</h1><p>通信的内容与并行方式有关。但是无论是数据并行还是模型并行，都需要在各个工作节点之间进行相互通信。总体而言，通信的内容可以分为参数（或参数的更新）和计算的中间结果两类。</p><h2 id="1-1-参数或参数的更新"><a href="#1-1-参数或参数的更新" class="headerlink" title="1.1 参数或参数的更新"></a>1.1 参数或参数的更新</h2><p>在基于<strong>数据并行</strong>的分布式机器学习中，工作节点各自完成本地的学习任务，然后互相交流各自对模型的修改，或者直接同步各自的模型。因此，在此情形下通信的内容是模型的<strong>参数或者参数的更新</strong>。在很多机器学习任务中，参数以及参数的更新是稀疏的同时在训练过程中，随着模型趋于收敛，参数的更新也会越来越少，这都会使得通信量相对较少（或越变越少）。因此进行通信以获取参数和参数更新是一个比较高效的选择。</p><p><br></p><!--more--><h2 id="1-2-计算中间的结果"><a href="#1-2-计算中间的结果" class="headerlink" title="1.2 计算中间的结果"></a>1.2 计算中间的结果</h2><p>在基于<strong>模型并行</strong>的分布式机器学习中，通信内容往往是计算的中间结果。模型并行将一个完整的模型切分成若干小份，让每个工作节点负责其中一部分，共同协作来完成模型的训练。因为各个工作节点所负责的模型参数没有重叠，所以不需要进行通信以获取模型参数。然而，为了完成并行训练，不同的工作节点之间需要进行通信以获取相互依赖的中间计算结果。</p><p>具体而言，在前向传播时，数据从底层进入模型，沿着神经元之间的连边进行传播，从而产生中间层节点的激活函数值；在后向传播时，总体误差会从输出节点反向传播，从而产生中间层节点的误差信息和梯度更新值。这个过程中存在一些边连接着两个属于不同工作节点的子模型，于是我们需要按照连接关系在对应的工作节点之间进行通信，以供其完成各自的计算。</p><p><br></p><h2 id="1-3-讨论"><a href="#1-3-讨论" class="headerlink" title="1.3 讨论"></a>1.3 讨论</h2><p>通信的目的是让工作节点互相交流它们各自的学习进展，不论是<strong>模型参数</strong>本身还是<strong>训练过程中的中间结果</strong>，本质上都是对于各个工作节点所获得的学习进展的表达方法。通过相互通信使<strong>总体的模型向正确的方向更新</strong>。</p><p><br></p><h1 id="二、通信的拓扑结构"><a href="#二、通信的拓扑结构" class="headerlink" title="二、通信的拓扑结构"></a>二、通信的拓扑结构</h1><p>通信的拓扑结构指分布式机器学习系统中各个工作节点之间的连接方式。拓扑结构一般分为物理拓扑结构和逻辑拓扑结构两种。</p><p>早期由于数据量不大、模型不复杂时，分布式机器学习常常利用已有的分布式计算框架来实现通信，如<strong>消息通信接口（MPI）或者 MapReduce 计算框架。</strong>但也有本身的局限性，例如，使用 MPI 的方式，各个节点之间仅支持同步计算。</p><p>随着数据量増大，模型变得越来越复杂，人们设计了参数服务器这样的分布式机器学习系统。通过采用二部图的网络拓扑结构，参数服务器可以支持基于<strong>异步通信</strong>的并行训练。后来，随着深度学习的普及，机器学习系统将计算和通信统一抽象为一个<strong>数据图模型</strong>，通信可以在任意两个相连的图节点之间产生。</p><h2 id="2-1-基于迭代式-MapReduce-AllReduce-的通信拓扑"><a href="#2-1-基于迭代式-MapReduce-AllReduce-的通信拓扑" class="headerlink" title="2.1 基于迭代式 MapReduce/ AllReduce 的通信拓扑"></a>2.1 基于迭代式 MapReduce/ AllReduce 的通信拓扑</h2><p>当我们把 <strong>MapReduce</strong> 的概念应用到分布式机器学习中，Map 操作定义了数据分发以及在本地工作节点上的计算，而 Reduce 操作则定义了全局参数的聚合过程。利用<strong>迭代式 MapReduce (IMR）</strong>操作可以实现典型的数据并行模式下的<strong>同步分布式机器学习算法</strong>。</p><p>另一种常用的分布式计算框架是<strong>消息通信接口（MPI</strong>）。程序设计人员主要使用其中的 AllReduce 接口来同步任何想要同步的信息，该接口支持所有符合 Reduce 规则的运算（比如求和、求平均、求最大值、求最小值等）。</p><p>分布式机器学习中基本的<strong>模型聚合方法</strong>主要是加和与平均，所以正好适合用 AllReduce 逻辑来处理。AllReduce 定义了一个标准接口，可以有多种实现方式。这些实现方式对应于不同的通信拓扑结构，包括星形拓扑、树形拓扑、蝶形拓扑等。各种拓扑结构在传输次数和传输量方面不尽相同，请参见下表。我们可以依据工作节点数和传输数据量选择合适的通信拓扑结构。</p><p><img src="http://sshpark.github.io/images/20191024101258.jpg" width="500px" /></p><p>总体来说，不论是 IMR 还是 AllReduce 的模式都只能支持同步通信，并且从接口调用上可以看出，各个工作节点使用的逻辑都是统一的，同步时各个工作节点提供的信息都必须是针对同一组参数的。这也就暗示着要求每个工作节点能够处理完整的模型，这点对于模型规模很大的问题不太适用。</p><p><br></p><h2 id="2-2-基于参数服务器的通信拓扑"><a href="#2-2-基于参数服务器的通信拓扑" class="headerlink" title="2.2 基于参数服务器的通信拓扑"></a>2.2 基于参数服务器的通信拓扑</h2><p>采用 IMR 或 Allreduce 机制的分布式系统的训练速度往往取决于系统中最慢的节点；而更加严重的情况是，如果系统中有的工作节点不响应了（比如硬盘出现故障或者网卡出现问题），那么整个系统只能停下来，无法继续工作。其次，当机器学习任务中的模型参数非常多，已经超出了单个机器的内存容限时，IMR 或 AllReduce 架构也将无法胜任。</p><p>最后，近些年来研究人员提出了很多异步算法，这些算法无法由同步计算的框架实现。为了解决这些挑战，一种新型的分布式机器学习框架应运而生，那就是<strong>基于参数服务器的框架。</strong></p><p><img src="http://sshpark.github.io/images/20191024102954.jpeg" width="500px" /></p><p>在参数服务器框架（上图) 中，系统中的所有节点被逻辑上分为<strong>工作节点（worker）</strong>和<strong>服务器节点（server）</strong>。各个工作节点主要负责处理本地的训练任务，并通过客户端接口与参数服务器通信，从参数服务器处获取最新的模型参数，抑或将本地训练产生的模型（或模型更新）发送到参数服务器。参数服务器框架中的灵魂是参数服务器（Parameter Server, PS）本身。PS 可以由单个服务器担任，也可以由一组服务器共同担任。可以看出，在逻辑上，参数服务器框架采用了二部图的通信拓扑结构。其中，工作节点和服务器节点之间彼此通信，而工作节点内部则无须通信。当服务器仅有一合时，便退化成为一个星形拓扑结构。</p><p><br></p><h2 id="2-3-基于数据流的通信拓扑"><a href="#2-3-基于数据流的通信拓扑" class="headerlink" title="2.3 基于数据流的通信拓扑"></a>2.3 基于数据流的通信拓扑</h2><p>在前面介绍的几种通信拓扑中，各个工作节点的运行逻辑是基本一致的，因此比较适合基于数据并行的分布式机器学习。</p><p>当我们进行基于模型并行的分布式机器学习时，则需要把不同类型的计算（例如不同子模型的更新）放置在不同的工作节点上。</p><p>近些年来，人们设计了<strong>基于数据流的分布式机器学习系统</strong>。在这种系统中，计算被描述为一个<strong>有向无环的数据流图。</strong>图中的每个节点进行数据处理或者计算，每条边代表数据的流动。当两个节点位于两台不同的机器上时，它们之间便会进行通信。</p><p>下图给出了一个工作节点逻辑的示例，每个节点实际上有两个通信通道：<strong>控制消息流和计算数据流</strong>。其中，<strong>计算数据流</strong>主要负责接收模型训练时所需要的数据、模型参数等，再经过工作节点内部的计算单元，产生输出数据（这里的数据可以是中间计算结果，也可以是参数更新），按需提供给下游的工作节点。控制消息流决定了工作节点应该接收什么数据，接收的数据是否已经完整，自己所要做的计算是否完成，是否可以让下游节点继续计算等。在工作节点定义时，需要指定工作节点的状态转换流程，从而在需要的时候生成一些信息，通过控制消息流通知后续节点准备进入消息接收和计算的状态。</p><p><img src="http://sshpark.github.io/images/20191024104742.jpeg" width="700px" /></p><p>其实数据流图是个很宽泛的概念，Mapreduce 和参数服务器的流程也可以用数据流图来表达。</p><p><br></p><h2 id="2-4-讨论"><a href="#2-4-讨论" class="headerlink" title="2.4 讨论"></a>2.4 讨论</h2><p>在不同的分布式机器学习系统背后有着不同的通信拓扑结构，这些结构是研究人员和工程技术人员多年经验的积累，并且在实践中被大量使用。比如 MapReduce/AllReduce 在 Hadoop/Spark/REEF 中被大量使用，参数服务器被现在众多的大規模分布式机器学习系统（如 MxNet、Paddle、DMTK、Petumm）使用，而数据流图则被分布式深度学习框架所使用（如 TensorFlow）。它们各自存在于特定的应用场景，但分布式的思想却可以相互借鉴，因此将长期共存和共同发展，并推动分布式机器学习算法的不断创新。</p><p><br></p><h1 id="三、通信的步调"><a href="#三、通信的步调" class="headerlink" title="三、通信的步调"></a>三、通信的步调</h1><p>所有的工作节点以同样的步调进行训练，这种通信模式称为<strong>同步通信。</strong>同步的通信步调能够保证分布式算法与单机算法的等价性，从而利于算法的分析和调试。但这需要各个工作节点之间彼此等待，造成计算资源闲置。因而这种方式具有<strong>算法上的优势但有系统上的劣势</strong>。</p><p>另一种方式则对所有工作节点的步调是否一致没有任何要求，称为<strong>异步通信</strong>。采用异步通信的方式时，各个机器可以按照自己的步调训练，无须彼此等待，从而最大化计算资源的利用率。但这种方式会使得各个工作节点之间的模型彼此不一致，存在延迟的问题。因而这种方式<strong>具有系统上的优势，但有算法上的劣势</strong>。在这两种极端的通信步调中间，还存在着一种折中的方式，以平衡同步和异步的优缺点。</p><h2 id="3-1-同步通信"><a href="#3-1-同步通信" class="headerlink" title="3.1 同步通信"></a>3.1 同步通信</h2><p>同步通信是指当集群中的一个工作节点完成本轮迭代后，需要等待集群中的其他工作节点都完成各自的任务，才能共同进行下一轮送代。</p><p>使用同步通信方式，可以确保各个工作节点模型的一致性。有些利用同步通信方式进行并行训练的分布式机器学习算法与其对应的单机优化算法等价。</p><p>但另一方面，同步方式由于要求各个机器之间的步调完全一致，会遇到<strong>掉队者（straggler）</strong>的麻烦。整个系统的效率取决于集群中运行最慢的节点。当参与分布式学习的工作节点之间存在显著性能差异时，同步通信很容易导致比较快的工作节点等待其他节点的现象。这个问题随着机器数量的増加变得愈加严重。因此，为了缓解这个问题，人们转而研究异步通信。</p><p><br></p><h2 id="3-2-异步通信"><a href="#3-2-异步通信" class="headerlink" title="3.2 异步通信"></a>3.2 异步通信</h2><p>异步通信是指当集群中的一个工作节点完成本轮迭代后，无须等待集群中的其他工作节点，就可以继续进行后续训练，因此系统效率可以大大提高（如下图所示）。然而，它会使得来自不同工作节点的模型参数之间存在延迟的现象，给模型聚合带来一定的挑战。</p><p><img src="http://sshpark.github.io/images/20191024110508.jpeg" width="600px" /></p><h3 id="3-2-1-多机的异步通信"><a href="#3-2-1-多机的异步通信" class="headerlink" title="3.2.1 多机的异步通信"></a>3.2.1 多机的异步通信</h3><p>在多机异步通信系统中存在两种逻辑角色：本地工作节点（worker）和参数服务器节点（parameter server）。在学习的过程中，每个工作节点基于本地样本计算出参数更新（例如梯度），而参数服务器节点则负责保存和管理全局参数。在这样的框架中，各个工作节点之间是不需要相互通信的，因此它们可以完全按照自己的速度进行本地的模型训练，当完成一次本地的参数更新之后，直接通过参数服务器的 API，将更新推送到全局模型，随后就可以毫无顾忌地继续进行本地的下一轮参数更新。</p><p>但是会存在“延时”问题，举个例子，某个工作节点速度很快，它已经在全局模型的基础上往前训练了 100 轮；而另外一个工作节点速度慢，它オ在同一个全局模型的基础上往前训练了 1 轮。这很可能会减慢全局模型的收敛速率。</p><h3 id="3-2-2-多线程的异步通信"><a href="#3-2-2-多线程的异步通信" class="headerlink" title="3.2.2 多线程的异步通信"></a>3.2.2 多线程的异步通信</h3><p>当数据规模不太大时，大家通常会选择利用单机的多线程并行处理能力，而不是借助计算机集群来实现分布式计算。由于内存访问的速度远超过网络传输的速度，因而在规模不大时，这样并行所需要的时间更少。</p><p>在这类单机多线程并行的学习过程中，有多个线程同时访问模型参数，原则上需要对参数加锁来控制多线程访问中的冲突问题。然而，由于参数的更新速度很快，锁的获取所花费的时间在此类机器学习任务中是非常可观的，这往往会导致多线程的并行学习得不到理想的加速比。为了解決这个问题，人们提出了 <strong>Hogwild！算法</strong>。在 <strong>Hogwild！</strong>算法中，各个工作线程都<strong>直接无锁（lock-free）地读取和写人最新的模型及其更新</strong>。可以证明，在优化目标为凸函数且模型更新比较稀疏的情况下，异步无锁的写人不会对收敛性造成本质影响。因此，我们可以比较放心地使用多线程异步通信来实现快速的单机并行训练。在后续章节中我们还会专门介绍有关 Hogwild！算法的详细流程。</p><p>但是随着训练数据的继续增加，单机的计算能力还是会逊色于多机集群，因此大多数并行框架是工作在多机集群环境下的。实践中，通常会结合单机共享内存的本地加速方法和多机同步或异步的分布式机制共同完成大规模的机器学习任务。</p><p><br></p><h2 id="3-3-同步和异步的平衡"><a href="#3-3-同步和异步的平衡" class="headerlink" title="3.3 同步和异步的平衡"></a>3.3 同步和异步的平衡</h2><p>下面我们将介绍其中一种比较经典的方法：延时同步并行（Stale Synchronous Parallel, SSP）</p><p>在极端情形下，异步通信可能存在非常大的延迟，从而导致学习过程收敛缓慢。但是实际系统中，我们通常遇到的情形又如何呢？答案是<strong>视集群的具体情况而论</strong>，也视实际的并行节点数目而论。</p><p>在实际的应用中，我们往往会采用一个相对同质化的集群（各个机器的计算性能和网络性能都趋于相同，并且相对稳定），并且不是所有时候都会有非常大量的节点参与运算。这时各个节点之间不存在非常明显的速度差异，偶尔有的机器快一点，有的机器慢一点，但是这种快慢变化大都是随机的，从相当长的一段时间来看，各个工作节点的平均速度应该趋于相同。在这种情况下，如果让各个工作节点异步执行，并且加上一定的控制逻辑，可能就不会出现之前那种令人担忧的情形了。</p><p>SSP 正是针对这种场景设计出来的。它的核心思想是<strong>控制最快和最慢节点之间相差的迭代次数不超过预设的國值</strong>。</p><p>下图对 SSP 的流程给出了形象的描述。在图中，阈值设为 3, 工作节点 1 是其中运算比较快的工作节点，而工作节点 2 是运算比较慢的工作节点。在工作节点 1 完成第 6 次更新的时候，工作节点 2 还在进行第 3 次更新。这时工作节点 1 已经领先太多，或者反过来说工作节点 2 所进行的更新的延迟太大了。这将会触发 SSP 算法中的等待机制。也就是说，此时工作节点 1 的最新参数请求将会被挂起，直到工作节点 2 到达第 4 次迭代位置才会解冻。在 SSP 的逻辑控制下，<strong>只要各个工作节点的迭代次数的差不超过预设的國值</strong>，则各个节点的运算就可以独立进行，不互相干扰。但是一且迭代次数差异太大就会触发一些等待，避免产生过大的延迟。</p><p><img src="http://sshpark.github.io/images/20191024113137.jpeg" width="700px" /></p><h2 id="3-4-讨论"><a href="#3-4-讨论" class="headerlink" title="3.4 讨论"></a>3.4 讨论</h2><p>本节中我们讨论了不同的通信步调。不同的步调各有优缺点。在实践中，通常需要根据训练任务、数据规模、集群规模、使用场景等选择采用哪种方式。现阶段，很多工业应用中仍然在使用同步算法。这主要是由于同步算法的稳定性和可重复性很强，对实现产品的质量控制很有帮助。虽然同步算法的效率不高，但是也可以通过某种方式（如备份工作节点等）来提高速度。</p><p><br></p><h1 id="四、通信的频率"><a href="#四、通信的频率" class="headerlink" title="四、通信的频率"></a>四、通信的频率</h1><p>在分布式机器学习中，通信是必要环节，同时也是相比于单机学习而言多出来的系统开销。<strong>通信与计算的时间比例</strong>往往决定了分布式机器学习系统加速比的上限。</p><p>本节我们讨论<strong>通信的频率</strong>。在设计分布式机器学习系统时，研究人员采用了多种方法来降低通信代价。这些方法主要<strong>利用机器学习算法的容错性特点</strong>，适当降低通信的频率，从而减少通信开销。在本章中，我们把通信频率分为<strong>时间频率</strong>和<strong>空间频率</strong>两种。其中，时间频率主要指通信的频次间隔，而空间频率主要指通信的内容大小。相应地，优化通信频率可以从两方面进行，即时域滤波和空域滤波。</p><h2 id="4-1-时域滤波"><a href="#4-1-时域滤波" class="headerlink" title="4.1 时域滤波"></a>4.1 时域滤波</h2><p>时域滤波的方法旨在从通信的过程出发，控制通信的时机，减少通信次数，从而减少通信代价。采用时域滤波的主要方法有增加通信间隔、非对称的推送和获取以及计算和传输流水线。</p><p><br></p><h2 id="4-2-空域滤波"><a href="#4-2-空域滤波" class="headerlink" title="4.2 空域滤波"></a>4.2 空域滤波</h2><p>空域滤波的方法旨在从通信的内容出发，尽量减少要通信的数据量，对传输的内容进行<strong>过滤、压缩或者量化</strong>，减少每一次传输所需的时间。接下来我们就介绍几种比较有代表性的做法。</p><h3 id="4-2-1-模型过滤"><a href="#4-2-1-模型过滤" class="headerlink" title="4.2.1 模型过滤"></a>4.2.1 模型过滤</h3><p>种比较直观的方法是对模型参数进行过滤。其基本思想是，如果一次送代中某些参数没有明显变化，便可以将其过滤掉，从而减少通信量。</p><p>实践中发现，在模型训练的后期，通过这样的方法甚至可以过滤掉 99%的参数，而模型仍然可以收敛到原有的精度。</p><h3 id="4-2-2-模型低秩化处理"><a href="#4-2-2-模型低秩化处理" class="headerlink" title="4.2.2 模型低秩化处理"></a>4.2.2 模型低秩化处理</h3><p>模型过滤通过去除不重要的参数来减少通信量，而模型低秩化处理则通过<strong>低秩分解压缩参数来减少通信量</strong>。这种方法探索了参数中的低秩结构，其具体做法是通过矩阵低秩分解，如 SVD 分解，将原来比较大的参数矩阵分解成几个比较小的矩阵的乘积。在网络通信的时候实际传输的是分解得到的比较小的矩阵，在传输之后再重新恢复成比较大的参数矩阵。</p><p><font color="red">需要注意的是：</font>采用以上方法，虽然可以减少通信量，但是会带来额外的压缩与解压缩的开销。因而在实践中，通常需要权衡这些额外开销与减少的通信开销，从而得到更好的系统性能。</p><h3 id="4-2-3-模型量化"><a href="#4-2-3-模型量化" class="headerlink" title="4.2.3 模型量化"></a>4.2.3 模型量化</h3><p>除了<strong>参数过滤</strong>和<strong>参数矩阵低秩化处理</strong>之外，还有一类方法通过对要传输的信息的精度进行控制来降低通信代价。这种方法通过降低参数的每一维浮点数的精度来减少通信量。比如，在<strong>一比特量化方法</strong>中，将原本需要通过网络传输的参数更新信息，从 <strong>32 比特的浮点数</strong>压缩到了 <strong>1 比特的二进制数</strong>，从而把网络通信量压缩了 32 倍。具体的算法如下所示。</p><p><img src="http://sshpark.github.io/images/20191024191356.jpg" width="600px" /></p><h3 id="4-3-讨论"><a href="#4-3-讨论" class="headerlink" title="4.3 讨论"></a>4.3 讨论</h3><p>通信的效率对分布式机器学习的加速效果有很大影响，通常是分布式机器学习中的瓶颈。本节介绍了通信的频率，以及如何通过滤波的方式降低通信的频率。我们可以从<strong>时间上进行滤波</strong>，从通信的过程出发，减少全局通信的次数和时间。我们也可以在<strong>空间上进行滤波</strong>，从通信的内容出发，减少通信量和通信时间。我们讨论了模型过滤、低秩压缩以及模型量化三种空域滤波方法。实践中，这些方法也常常结合在一起使用，以获取最大限度的效率提升。</p><p><br></p><h3 id="五、参考书籍"><a href="#五、参考书籍" class="headerlink" title="五、参考书籍"></a>五、参考书籍</h3><p>《分布式机器学习：算法、理论与实践》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;分布式机器学习&lt;/strong&gt;与&lt;strong&gt;单机版的机器学习&lt;/strong&gt;最大区别在于，它利用了多个工作节点同时训练、相互合作来加速学习过程。既然需要相互合作，那么通信就成为必不可少的环节。不过，分布式系统中的网络传输速度往往受限，导致通信常常成为分布式系统的瓶颈。举一个简单的例子：如果某个任务中计算与通信的时间占比为 1:1, 那么根据&lt;strong&gt;阿姆达尔定律（Amdahl’s law）&lt;/strong&gt;，无论使用多少台机器做并行运算，其加速比都不会超过两倍。因此，分布式机器学习的关键是设计通信机制，从而降低通信与计算的时间比例，更加高效地训练出高精度的模型。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="分布式机器学习" scheme="http://sshpark.com.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode Weekly Contest 157</title>
    <link href="http://sshpark.com.cn/2019/10/06/LeetCode-Weekly-Contest-157/"/>
    <id>http://sshpark.com.cn/2019/10/06/LeetCode-Weekly-Contest-157/</id>
    <published>2019-10-06T07:07:12.000Z</published>
    <updated>2021-05-25T11:21:27.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1217-Play-with-Chips"><a href="#1217-Play-with-Chips" class="headerlink" title="1217.Play with Chips"></a>1217.Play with Chips</h2><p>There are some chips, and the i-th chip is at position <code>chips[i]</code>.</p><p>You can perform any of the two following types of moves <strong>any number of times</strong> (possibly zero) <strong>on any chip</strong>:</p><ul><li>Move the <code>i</code>-th chip by 2 units to the left or to the right with a cost of <strong>0</strong>.</li><li>Move the <code>i</code>-th chip by 1 unit to the left or to the right with a cost of <strong>1</strong>.</li></ul><p>There can be two or more chips at the same position initially.</p><p>Return the minimum cost needed to move all the chips to the same position (any position).</p><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: chips = [1,2,3]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: Second chip will be moved to positon 3 with cost 1. First chip will be moved to position 3 with cost 0. Total cost is 1.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= chips.length &lt;= 100</code></li><li><code>1 &lt;= chips[i] &lt;= 10^9</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>简单题，因为数据范围很小，可以考虑暴力，时间复杂度为 <code>O(n^2)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostToMoveChips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; chips)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = chips.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> mina = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">                    temp += <span class="built_in">abs</span>(chips[i]-chips[j])&amp;<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mina = <span class="built_in">min</span>(mina, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mina;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><a id="more"></a><h2 id="1218-Longest-Arithmetic-Subsequence-of-Given-Difference"><a href="#1218-Longest-Arithmetic-Subsequence-of-Given-Difference" class="headerlink" title="1218.Longest Arithmetic Subsequence of Given Difference"></a>1218.Longest Arithmetic Subsequence of Given Difference</h2><p>Given an integer array <code>arr</code> and an integer <code>difference</code>, return the length of the longest subsequence in <code>arr</code> which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals <code>difference</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,2,3,4], difference = 1</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest arithmetic subsequence is [1,2,3,4].</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= arr[i], difference &lt;= 10^4</code></li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>从前往后遍历，每遍历到一个数字的时候判断前面是否有满足的数，即 $arr[i]-difference$，用 map 存储次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mm;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mm.<span class="built_in">find</span>(arr[i]-difference) == mm.<span class="built_in">end</span>()) mm[arr[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> mm[arr[i]] = mm[arr[i]-difference]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxa = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it : mm) maxa = <span class="built_in">max</span>(maxa, it.second);</span><br><span class="line">        <span class="keyword">return</span> maxa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="1219-Path-with-Maximum-Gold"><a href="#1219-Path-with-Maximum-Gold" class="headerlink" title="1219.Path with Maximum Gold"></a>1219.Path with Maximum Gold</h2><p>In a gold mine <code>grid</code> of size <code>m * n</code>, each cell in this mine has an integer representing the amount of gold in that cell, <code>0</code> if it is empty.</p><p>Return the maximum amount of gold you can collect under the conditions:</p><ul><li>Every time you are located in a cell you will collect all the gold in that cell.</li><li>From your position you can walk one step to the left, right, up or down.</li><li>You can’t visit the same cell more than once.</li><li>Never visit a cell with <code>0</code> gold.</li><li>You can start and stop collecting gold from <strong>any</strong> position in the grid that has some gold.</li></ul><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[0,6,0],[5,8,7],[0,9,0]]</span><br><span class="line">Output: 24</span><br><span class="line">Explanation:</span><br><span class="line">[[0,6,0],</span><br><span class="line"> [5,8,7],</span><br><span class="line"> [0,9,0]]</span><br><span class="line">Path to get the maximum gold, 9 -&gt; 8 -&gt; 7.</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= grid.length, grid[i].length &lt;= 15</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li><li>There are at most <strong>25</strong> cells containing gold.</li></ul><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>数据范围同样很小，遍历每一个位置作为起点，然后 <strong>dfs + 回溯</strong> 更新最大值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaximumGold</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &gt; <span class="number">0</span>)</span><br><span class="line">                    res = <span class="built_in">max</span>(res, grid[i][j]+dfs(grid, i, j));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = grid[x][y];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x+dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ny = y+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nx &lt; grid.<span class="built_in">size</span>() &amp;&amp; nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; grid[nx][ny] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, grid[nx][ny]+dfs(grid, nx, ny));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = temp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="1220-Count-Vowels-Permutation"><a href="#1220-Count-Vowels-Permutation" class="headerlink" title="1220.Count Vowels Permutation"></a>1220.Count Vowels Permutation</h2><p>Given an integer <code>n</code>, your task is to count how many strings of length <code>n</code> can be formed under the following rules:</p><ul><li>Each character is a lower case vowel (<code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, <code>&#39;u&#39;</code>)</li><li>Each vowel <code>&#39;a&#39;</code> may only be followed by an <code>&#39;e&#39;</code>.</li><li>Each vowel <code>&#39;e&#39;</code> may only be followed by an <code>&#39;a&#39;</code> or an <code>&#39;i&#39;</code>.</li><li>Each vowel <code>&#39;i&#39;</code> <strong>may not</strong> be followed by another <code>&#39;i&#39;</code>.</li><li>Each vowel <code>&#39;o&#39;</code> may only be followed by an <code>&#39;i&#39;</code> or a <code>&#39;u&#39;</code>.</li><li>Each vowel <code>&#39;u&#39;</code> may only be followed by an <code>&#39;a&#39;.</code></li></ul><p>Since the answer may be too large, return it modulo <code>10^9 + 7.</code></p><p> <strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: All possible strings are: "a", "e", "i" , "o" and "u".</span><br></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 2 * 10^4</code></li></ul><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>占个坑，使用 DP 或者数学推公式（矩阵快速幂）</p><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countVowelPermutation</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Solution::countVowelPermutation(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* dp[i][j] denotes the number of valid strings of length n */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i+<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">1</span>] + dp[i][<span class="number">2</span>] + dp[i][<span class="number">4</span>]) %MOD;</span><br><span class="line">        </span><br><span class="line">        dp[i+<span class="number">1</span>][<span class="number">1</span>] = (dp[i][<span class="number">0</span>] + dp[i][<span class="number">2</span>]) % MOD;</span><br><span class="line">        </span><br><span class="line">        dp[i+<span class="number">1</span>][<span class="number">2</span>] = (dp[i][<span class="number">1</span>] + dp[i][<span class="number">3</span>]) % MOD;</span><br><span class="line">        </span><br><span class="line">        dp[i+<span class="number">1</span>][<span class="number">3</span>] = dp[i][<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        dp[i+<span class="number">1</span>][<span class="number">4</span>] = (dp[i][<span class="number">2</span>] + dp[i][<span class="number">3</span>]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        res = (res + dp[n][i]) % MOD;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      leetcode 第 157 场周赛
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://sshpark.com.cn/tags/LeetCode/"/>
    
      <category term="dfs" scheme="http://sshpark.com.cn/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>贪吃蛇小游戏--SFML实现</title>
    <link href="http://sshpark.com.cn/2019/09/26/%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F-SFML%E5%AE%9E%E7%8E%B0/"/>
    <id>http://sshpark.com.cn/2019/09/26/%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F-SFML%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-09-25T16:14:48.000Z</published>
    <updated>2021-05-25T11:21:27.986Z</updated>
    
    <content type="html"><![CDATA[<p>经典游戏 —— 贪吃蛇。游戏的实现很简单，只要理清需要用什么数据结构表示蛇以及更新逻辑就好。这里使用 <strong>SFML</strong> 实现。</p><h3 id="一、蛇的表示"><a href="#一、蛇的表示" class="headerlink" title="一、蛇的表示"></a>一、蛇的表示</h3><p>我们可以将蛇身体每一部分存储起来，这里只需要储存每一部分的坐标值。如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SnakeSegment</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    SnakeSegment(<span class="keyword">int</span> xx, <span class="keyword">int</span> yy): x(xx), y(yy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> SnakeSegment&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x == other.x &amp;&amp; <span class="keyword">this</span>-&gt;y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&lt;/br&gt;</p><h3 id="二、更新逻辑"><a href="#二、更新逻辑" class="headerlink" title="二、更新逻辑"></a>二、更新逻辑</h3><p>这里的话，我们需要考虑的逻辑有：</p><ul><li>在每一步的更新中，蛇的每一部分的<strong>坐标</strong>都在变化</li><li>如果撞到自身，那么游戏重新开始</li><li>判断是否吃到了食物</li><li>边界处理</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = snake.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">        snake[i] = snake[i+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="number">0</span>) snake[n<span class="number">-1</span>].x--; <span class="keyword">if</span> (dir == <span class="number">1</span>) snake[n<span class="number">-1</span>].y++;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="number">2</span>) snake[n<span class="number">-1</span>].x++; <span class="keyword">if</span> (dir == <span class="number">3</span>) snake[n<span class="number">-1</span>].y--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::find(snake.begin(), snake.end()<span class="number">-1</span>, snake[n<span class="number">-1</span>]) != snake.end()<span class="number">-1</span>)</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (snake[n<span class="number">-1</span>].x == fruit.x &amp;&amp; snake[n<span class="number">-1</span>].y == fruit.y) &#123;</span><br><span class="line">        fruit.x = rand() % (windowWidth<span class="number">-2</span>)+<span class="number">1</span>;</span><br><span class="line">        fruit.y = rand() % (windowHeight<span class="number">-2</span>)+<span class="number">1</span>;</span><br><span class="line">        snake.push_back(snake[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (snake[n<span class="number">-1</span>].x &gt;= windowWidth<span class="number">-1</span>) snake[n<span class="number">-1</span>].x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (snake[n<span class="number">-1</span>].x &lt; <span class="number">1</span>) snake[n<span class="number">-1</span>].x = windowWidth<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (snake[n<span class="number">-1</span>].y &gt;= windowHeight<span class="number">-1</span>) snake[n<span class="number">-1</span>].y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (snake[n<span class="number">-1</span>].y &lt; <span class="number">1</span>) snake[n<span class="number">-1</span>].y = windowHeight<span class="number">-2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;/br&gt;</p><h3 id="三、其他东西"><a href="#三、其他东西" class="headerlink" title="三、其他东西"></a>三、其他东西</h3><p>剩下的就是<strong>世界的绘制</strong>和<strong>键盘事件的处理</strong>，这两部分实现比较简单，这里就不贴代码了。完整代码可以参见<a href="https://github.com/sshpark/LearnSFML/tree/master/Snake" target="_blank" rel="noopener">这里</a></p><p>游戏展示：</p><p><img src="http://sshpark.github.io/images/20190926000954.gif" width="500px" /></p><p>&lt;/br&gt;</p><h3 id="四、后续"><a href="#四、后续" class="headerlink" title="四、后续"></a>四、后续</h3><p>作为展示，贪吃蛇游戏的代码实现过程较为简单，很多小细节没有去处理。例如，吃到食物之后蛇的身体没有立马更新、食物的随机生成没有考虑与蛇冲突、没有分数的展示等等，感兴趣的小伙伴可以动手去实现自己的贪吃蛇小游戏。😃</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;经典游戏 —— 贪吃蛇。游戏的实现很简单，只要理清需要用什么数据结构表示蛇以及更新逻辑就好。这里使用 &lt;strong&gt;SFML&lt;/strong&gt; 实现。&lt;/p&gt;
&lt;h3 id=&quot;一、蛇的表示&quot;&gt;&lt;a href=&quot;#一、蛇的表示&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
    
      <category term="SFML" scheme="http://sshpark.com.cn/tags/SFML/"/>
    
  </entry>
  
  <entry>
    <title>贝尔曼方程</title>
    <link href="http://sshpark.com.cn/2019/09/15/%E8%B4%9D%E5%B0%94%E6%9B%BC%E6%96%B9%E7%A8%8B/"/>
    <id>http://sshpark.com.cn/2019/09/15/%E8%B4%9D%E5%B0%94%E6%9B%BC%E6%96%B9%E7%A8%8B/</id>
    <published>2019-09-15T13:09:20.000Z</published>
    <updated>2021-05-25T11:21:28.015Z</updated>
    
    <content type="html"><![CDATA[<p>强化学习中的 <strong>State value function</strong> 和 <strong>Q function</strong>。</p><a id="more"></a><h3 id="1、一些概念"><a href="#1、一些概念" class="headerlink" title="1、一些概念"></a>1、一些概念</h3><h4 id="1-1、回报（Return）"><a href="#1-1、回报（Return）" class="headerlink" title="1.1、回报（Return）"></a>1.1、回报（Return）</h4><p>智能体的目标是最大化回报。通常，回报需要定义一个折扣因子 $\gamma$，回报函数如下：</p><script type="math/tex; mode=display">\begin{aligned}G_t &= R_{t+1}+\gamma R_{t+2}+\gamma^2 R_{t+3}...\\    &= \sum_{k = 0}^{\infty}\gamma^k r_{t+k+1}\end{aligned}</script><h4 id="1-2、策略（Policy）"><a href="#1-2、策略（Policy）" class="headerlink" title="1.2、策略（Policy）"></a>1.2、策略（Policy）</h4><p>策略的定义为 $ \pi: S \rightarrow A $</p><h4 id="1-3、State-value-function"><a href="#1-3、State-value-function" class="headerlink" title="1.3、State value function"></a>1.3、State value function</h4><p><strong>State value function</strong>描述的是在策略 $\pi$ 下该状态 $s$ 下有多好。</p><script type="math/tex; mode=display">V^{\pi}(s)=\mathbb{E}_{\pi}[G_t|s_t=s]</script><h4 id="1-4、Q-function"><a href="#1-4、Q-function" class="headerlink" title="1.4、Q function"></a>1.4、Q function</h4><p><strong>Q function</strong> 描述的是在策略 $\pi$ 下，在状态 $s$ 采取动作 $a$ 有多好。</p><script type="math/tex; mode=display">Q^\pi(s, a) = \mathbb{E}[G_t|s_t=s,a_t=a]</script><p><br></p><h3 id="2、求解-State-value-function-和-Q-function"><a href="#2、求解-State-value-function-和-Q-function" class="headerlink" title="2、求解 State value function 和 Q function"></a>2、求解 State value function 和 Q function</h3><p><strong>贝尔曼方程（Bellman equation）</strong>是理查德·贝尔曼推导出来的，可以帮助解决马尔可夫决策问题（MDP）。</p><p>根据回报的定义，我们可以将 <strong>State value function</strong> 表示为：</p><script type="math/tex; mode=display">\begin{aligned}V^\pi(s)&=\mathbb{E}_\pi[R_{t+1}+\gamma R_{t+2}+\gamma^2 R_{t+3}+...|s_t=s]\\&=\mathbb{E}_\pi[\sum_{k=0}^{\infty}\gamma^k R_{t+k+1}|s_t=s]\end{aligned}</script><p><strong>定理 1:</strong></p><script type="math/tex; mode=display">\mathbb{E}_{\pi}\left[\boldsymbol{v}_{\pi}\left(S_{t+1}\right) | \boldsymbol{S}_{t}\right]=\mathbb{E}_{\pi}\left[\mathbb{E}_{\pi}\left[\boldsymbol{G}_{t+1} | \boldsymbol{S}_{t+1}\right] | \boldsymbol{S}_{t}\right]=\mathbb{E}_{\pi}\left[\boldsymbol{G}_{t+1} | \boldsymbol{S}_{t}\right]</script><p><strong>证明</strong>：</p><p>其中 <script type="math/tex">{s}=S_{t,} {g}^{\prime}={G}_{t+1}, {s}^{\prime}={S}_{t+1}</script></p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}_{\pi}\left[\mathbb{E}_{\pi}\left[G_{t+1} | S_{t+1}\right] | S_{t}\right] &=\mathbb{E}_{\pi}\left[\mathbb{E}_{\pi}\left[g^{\prime} | s^{\prime}\right] | s\right] \\&=\sum_{s^{\prime}} \sum_{g^{\prime}} g^{\prime} p\left(g^{\prime} | s^{\prime}, s\right) p\left(s^{\prime} | s\right) \\&=\sum_{s^{\prime}} \sum_{g^{\prime}} \frac{g^{\prime} p\left(g^{\prime} | s^{\prime}, s\right) p\left(s^{\prime} | s\right) p(s)}{p(s)} \\&=\sum_{s^{\prime}} \sum_{g^{\prime}} \frac{g^{\prime} p\left(g^{\prime} | s^{\prime}, s\right) p\left(s^{\prime}, s\right)}{p(s)} \\&=\sum_{s^{\prime}} \sum_{g^{\prime}} \frac{g^{\prime} p\left(g^{\prime}, s^{\prime}, s\right)}{p(s)} \\&=\sum_{s^{\prime}} \sum_{g^{\prime}} g^{\prime} p\left(g^{\prime}, s^{\prime} | s\right) \\&=\sum_{g^{\prime}} \sum_{s^{\prime}} g^{\prime} p\left(g^{\prime}, s^{\prime} | s\right) \\&=\sum_{g^{\prime}} g^{\prime} p\left(g^{\prime} | s\right) \\&=\mathbb{E}_{\pi}\left[g^{\prime} | s\right]=\mathbb{E}_{\pi}\left[G_{t+1} | S_{t}\right]\end{aligned}</script><p>进而得到 <strong>State value function</strong></p><script type="math/tex; mode=display">\begin{aligned}v_{\pi}(s) &=\mathbb{E}_{\pi}\left[G_{t} | S_{t}=s\right] \\&=\mathbb{E}_{\pi}\left[R_{t+1}+\gamma R_{t+2}+\gamma^{2} R_{t+3}+\cdots | S_{t}=s\right] \\&=\mathbb{E}_{\pi}\left[R_{t+1}+\gamma \sum_{k=0}^{\infty} \gamma^{k} R_{(t+1)+k+1} | S_{t}=s\right] \\&=\mathbb{E}_{\pi}\left[R_{t+1}+\gamma G_{t+1} | S_{t}=s\right] \\&=\mathbb{E}_{\pi}\left[R_{t+1}+\gamma \mathbb{E}_{\pi}\left[G_{t+1} | S_{t+1}\right] | S_{t}=s\right] \\&=\mathbb{E}_{\pi}\left[R_{t+1}+\gamma v_{\pi}\left(S_{t+1}\right) | S_{t}=s\right] \\&=\sum_{a} \pi(a | s) \sum_{r} p(r | s, a) r+\gamma \sum_{a} \pi(a | s) \sum_{s^{\prime}} p\left(s^{\prime} | s, a\right) v_{\pi}\left(s^{\prime}\right) \\&=\sum_{a} \pi(a | s) \sum_{r} \sum_{s^{\prime}} p\left(s^{\prime}, r | s, a\right) r+\gamma \sum_{a} \pi(a | s) \sum_{r} \sum_{r} p\left(s^{\prime}, r | s, a\right) v_{\pi}\left(s^{\prime}\right) \\&=\sum_{a} \pi(a | s) \sum_{s^{\prime}} \sum_{r} p\left(s^{\prime}, r | s, a\right) r+\gamma \sum_{a} \pi(a | s) \sum_{s^{\prime}} \sum_{r} p\left(s^{\prime}, r | s, a\right) v_{\pi}\left(s^{\prime}\right) \\&=\sum_{a} \pi(a | s) \sum_{s^{\prime}} \sum_{r} p\left(s^{\prime}, r | s, a\right)\left[r+\gamma v_{\pi}\left(s^{\prime}\right)\right]\end{aligned}</script><p>同理可推导 <strong>Q function</strong> 为：</p><script type="math/tex; mode=display">q_{\pi}(s, a)=\sum_{s^{\prime}} \sum_{r} p\left(s^{\prime}, r | s, a\right)\left[r+\gamma v_{\pi}\left(s^{\prime}\right)\right]</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;强化学习中的 &lt;strong&gt;State value function&lt;/strong&gt; 和 &lt;strong&gt;Q function&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="强化学习" scheme="http://sshpark.com.cn/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>高斯分布下方差估计的推导</title>
    <link href="http://sshpark.com.cn/2019/09/14/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E4%B8%8B%E6%96%B9%E5%B7%AE%E4%BC%B0%E8%AE%A1%E7%9A%84%E6%8E%A8%E5%AF%BC/"/>
    <id>http://sshpark.com.cn/2019/09/14/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E4%B8%8B%E6%96%B9%E5%B7%AE%E4%BC%B0%E8%AE%A1%E7%9A%84%E6%8E%A8%E5%AF%BC/</id>
    <published>2019-09-14T13:37:49.000Z</published>
    <updated>2021-05-25T11:21:27.962Z</updated>
    
    <content type="html"><![CDATA[<p>考虑一组独立同分布的样本  $\{x^{(1)},…,x^{(m)}\}$ 服从高斯分布 $p(x^{(i)})=\mathcal{N}(x^{(i)};\mu,\sigma^2)$，其中 $i \in {1,…,m}$ 。</p><p>&lt;/br&gt;</p><h3 id="样本方差（sample-variance）"><a href="#样本方差（sample-variance）" class="headerlink" title="样本方差（sample variance）"></a>样本方差（sample variance）</h3><p>样本方差定义为</p><script type="math/tex; mode=display">\hat{\sigma}^{2}_{m} = \frac{1}{m}\sum_{i=1}^{m}(x^{(i)}-\hat{\mu}_{m})^2</script><p>其中 $\hat{\mu}_{m}$  是样本均值。</p><p>那么它的偏差为：$bias(\hat{\sigma}^{2}<em>{m})=\mathbb{E}[\hat{\sigma}^{2}</em>{m}]-\sigma^2$</p><p>以知的条件有：</p><ul><li>$\mathbb{E}(x^{(i)})=\mu$</li><li>$D(x^{(i)})=\sigma^2$</li><li>$D(x^{(i)})=\sigma^2=\mathbb{E}[(x^{(i)})^2]-\mathbb{E}[x^{(i)}]^2$</li><li>$\mathbb{E}(\hat{\mu}_{m})=\mu$</li><li>$D(\hat{\mu}<em>{m})=D(\frac{1}{n}\sum</em>{i=1}^{m}x^{(i)})=\frac{1}{n^2}D(\sum_{i=1}^{m}x^{(i)})=\frac{\sigma^2}{n}$</li></ul><p>那么有：</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[\hat{\sigma}^{2}_{m}]&=\mathbb{E}[\frac{1}{m}\sum_{i=1}^{m}(x^{(i)}-\hat{\mu}_{m})^2]\\&=\frac{1}{m}\mathbb{E}[\sum_{i=1}^{m}((x^{(i)})^2-2x^{(i)}\hat{\mu}_m+\hat{\mu}^2_{m})]\\&=\frac{1}{m}\mathbb{E}[\sum_{i=1}^{m}(x^{(i)})^2]-\frac{\hat{2\mu_m}}{m}\mathbb{E}[\sum_{i=1}^{m}x^{(i)}]+\frac{1}{m}\mathbb{E}[\sum_{i=1}^{m}\hat{\mu}^{2}_{m}]\\&=\frac{1}{m}\mathbb{E}[\sum_{i=1}^{m}(x^{(i)})^2]-\frac{1}{m}\mathbb{E}[2m\hat{\mu}^{2}_{m}]+\frac{1}{m}\mathbb{E}[m{\mu}^{2}_{m}]\\&=\frac{1}{m}\mathbb{E}[\sum_{i=1}^{m}(x^{(i)})^2]-\frac{1}{m}\mathbb{E}[m\hat{\mu}^{2}_{m}]\\&=\frac{1}{m}\sum_{i=1}^{m}(\mathbb{E}[(x^{(i)})^2]-\mathbb{E}[\hat{\mu}^{2}_{m}])\\&=\frac{1}{m}\sum_{i=1}^{m}(D(x^{(i)})+\mathbb{E}^2(x^{(i)})-D(\hat{\mu}_m)-\mathbb{E}^2(\hat{\mu}_m))\\&=\frac{1}{m}\sum_{i=1}^{m}(\sigma^2+\mu^2-\frac{\sigma^2}{m}-\mu^2)\\&=\frac{m-1}{m}\sigma^2\end{aligned}</script><p>因此前面的<strong>偏差</strong>为$bias(\hat{\sigma}^{2}_{m})=-\frac{\sigma^2}{m}$</p><p><br></p><h3 id="无偏样本方差（unbiased-sample-variance）"><a href="#无偏样本方差（unbiased-sample-variance）" class="headerlink" title="无偏样本方差（unbiased sample variance）"></a>无偏样本方差（unbiased sample variance）</h3><p>因此，下面这种估计是无偏的：</p><script type="math/tex; mode=display">\tilde{\sigma}_m^2=\frac{1}{m-1}\sum_{i=1}^{m}(x^{(i)}-\hat{\mu}_m)^2</script><p>可以知道 $\tilde{\sigma}_m^2=\sigma^2$</p>]]></content>
    
    <summary type="html">
    
      为什么高斯分布的无偏样本方差是除以 $m-1$ 而不是 $m$ ?
    
    </summary>
    
    
    
      <category term="机器学习基础" scheme="http://sshpark.com.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>用C++和SFML写游戏-2D 摄像机的使用（7）</title>
    <link href="http://sshpark.com.cn/2019/09/07/%E7%94%A8C-%E5%92%8CSFML%E5%86%99%E6%B8%B8%E6%88%8F-2D-%E6%91%84%E5%83%8F%E6%9C%BA%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%887%EF%BC%89/"/>
    <id>http://sshpark.com.cn/2019/09/07/%E7%94%A8C-%E5%92%8CSFML%E5%86%99%E6%B8%B8%E6%88%8F-2D-%E6%91%84%E5%83%8F%E6%9C%BA%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%887%EF%BC%89/</id>
    <published>2019-09-07T13:04:14.000Z</published>
    <updated>2021-05-25T11:21:27.985Z</updated>
    
    <content type="html"><![CDATA[<p>本文将会介绍怎么在程序中使用摄像机和 <strong>OpenGL</strong> 。对摄像机将会深入的介绍，而对于 <strong>OpenGL</strong>，我们这里只做简单的介绍。<strong>OpenGL</strong> 是一个很大的主题，一篇文章根本就不能够将它完全介绍清楚。</p><p>本文将会介绍以下内容：</p><ul><li>什么是摄像机</li><li>用 <code>sf::View</code> 操作摄像机</li><li>什么是 <strong>OpenGL</strong></li><li>在 <strong>SFML</strong> 中使用 <strong>OpenGL</strong><a id="more"></a>&lt;/br&gt;<h3 id="一、什么是摄像机"><a href="#一、什么是摄像机" class="headerlink" title="一、什么是摄像机"></a>一、什么是摄像机</h3></li></ul><p>实际上，在游戏开发中不使用摄像机的可能性很小，它是游戏的基本组成部分。本质上来看，摄像机就是空间中的一个点，通过这个点你可以观察到游戏中的世界。摄像机有很多参数设置，但在本文，我们只关注 <strong>SFML</strong> 为我们提供的东西。</p><p>在开始写代码之前，我们先直观的了解一下摄像机。由于 <strong>SFML</strong> 主要用于 <strong>2D</strong> 游戏开发。因此，它的 <strong>camera</strong> 类主要采用的是<strong><a href="https://baike.baidu.com/item/%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1" target="_blank" rel="noopener">正交投影（orthographic projection）</a></strong>。在这种投影下，物体看起来没有什么视觉上的变化。而在<strong><a href="https://baike.baidu.com/item/%E9%80%8F%E8%A7%86%E6%8A%95%E5%BD%B1" target="_blank" rel="noopener">透视投影（perspective projection）</a></strong>下，它采用了一种基于人眼看到事物的方式将物体在 <strong>2D</strong> 平面中展示出来（例如，距离的不同物体的大小也不同）。从下面的图片可以直观的了解一下这两种方式的区别：</p><p><img src="http://sshpark.github.io/images/20190907212724.png" width="500px" /></p><p>显然，在 <strong>2D</strong> 游戏中使用<strong>透视投影</strong>是没必要的，在 <strong>SFML</strong> 中甚至没有提供使用它的方式。使用 <strong>OpenGL</strong> 同样可以创建摄像机，这个将在后面介绍。</p><p>&lt;/br&gt;</p><h3 id="二、在-SFML-中使用摄像机"><a href="#二、在-SFML-中使用摄像机" class="headerlink" title="二、在 SFML 中使用摄像机"></a>二、在 SFML 中使用摄像机</h3><p>当然，我们也不是任何时候都适用摄像机。但是在一些有着庞大世界的 <strong>RPG</strong> 游戏中，我们就要用到了，因为屏幕的尺寸有限，不能完全的展示这个世界。</p><p>想要修改 <strong>sf::Window</strong> 中的摄像机，需要先解决 <strong>sf::View</strong> 类。<strong>sf::View</strong> 的行为就像是摄像机，它限制了玩家能够看到的内容。<strong>sf::View</strong> 的创建和使用如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wSize = window.getSize();</span><br><span class="line">sf::<span class="function">View <span class="title">view</span><span class="params">(sf::FloatRect(<span class="number">0</span>, <span class="number">0</span>, wSize.x, wSize.y))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 View</span></span><br><span class="line">window.setView(view);</span><br></pre></td></tr></table></figure><p><strong>View</strong> 的构造函数参数 <strong>FloatRect</strong> 表示的是截取世界的一部分给玩家看。如果 <strong>FloatRect</strong> 的大小大于当前窗口，那么它将会压缩显示。</p><p>&lt;/br&gt;</p><h3 id="三、用-sf-View-操作摄像机"><a href="#三、用-sf-View-操作摄像机" class="headerlink" title="三、用 sf::View 操作摄像机"></a>三、用 sf::View 操作摄像机</h3><p>默认情况下，view 的中心是视图区域的中心，也就是说，如果我们当前窗口大小是（640，480），那么 view 的中心是（320，240）。这时候将物体渲染到 view 上的时候，物体将出现在左上角（0，0）。改变 view 的中心可以使用 <code>View::setCenter()</code> 或者 <code>View::move()</code> 方法。</p><p>示例代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wSize = window.getSize();</span><br><span class="line">sf::<span class="function">View <span class="title">view</span><span class="params">(sf::FloatRect(<span class="number">0</span>, <span class="number">0</span>, wSize.x, wSize.y))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 view 中心</span></span><br><span class="line">view.setCenter(sf::Vector2f(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">window.setView(view);</span><br><span class="line"></span><br><span class="line">sf::Vector2f spriteSize = sf::Vector2f(<span class="number">118</span>, <span class="number">114</span>);</span><br><span class="line">sf::<span class="function">Sprite <span class="title">sprite</span><span class="params">(AssetManager::GetTexture(<span class="string">"myTexture.png"</span>))</span></span>;</span><br><span class="line">sprite.setTextureRect(sf::IntRect(<span class="number">0</span>, <span class="number">0</span>, spriteSize.x, spriteSize.y));</span><br><span class="line">sprite.setOrigin(spriteSize * <span class="number">0.5f</span>);</span><br></pre></td></tr></table></figure><p>上面的代码将 view 的中心设置为（0，0），那么世界中的该位置将会出现在屏幕中心。<strong>sprite</strong> 默认位置是（0，0），因此该精灵会出现在屏幕中心。</p><p><img src="http://sshpark.github.io/images/20190909190909.png" width="450px" /></p><p>通常，将 view 的中心设置在我们主要角色上是一个简单有效的方式去执行摄像机位置逻辑，同样，在每一帧更新的时候只需要一下两行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.setCenter(sprite.getPosition());</span><br><span class="line">window.setView(view);</span><br></pre></td></tr></table></figure><font color="red">需要注意的是，更新每一帧的时候需要再次调用 `RenderWindow::setView()`，因为**RenderWindow** 只保存 view 的副本，只更改旧的 view 不会影响存储在 **RenderWindow** 中的 view。</font><p>&lt;/br&gt;</p><h3 id="四、旋转和缩放-view"><a href="#四、旋转和缩放-view" class="headerlink" title="四、旋转和缩放 view"></a>四、旋转和缩放 view</h3><p>尽管这两个属性很少使用，但是当我们需要实现摄像机的一些特殊功能的时候会派上用场。</p><p>旋转的话有两个方法，<code>View::setRotation()</code> 和 <code>View::rotate()</code>。这两个方法的区别是 <code>View::setRotation()</code> 会将物体的旋转角度<strong>固定为给定的值</strong>，而 <code>View::rotate()</code> 则会在物体的当前旋转度上<strong>加上给定的值。</strong></p><p>通过一个例子来看看，这里使用了四个精灵。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wSize = window.getSize();</span><br><span class="line">sf::<span class="function">View <span class="title">view</span><span class="params">(sf::FloatRect(<span class="number">0</span>, <span class="number">0</span>, wSize.x, wSize.y))</span></span>;</span><br><span class="line">view.setCenter(sf::Vector2f(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 设置旋转 45 度</span></span><br><span class="line">view.setRotation(<span class="number">45</span>);</span><br><span class="line">window.setView(view);</span><br><span class="line"></span><br><span class="line">sf::Vector2f spriteSize = sf::Vector2f(<span class="number">118</span>, <span class="number">114</span>);</span><br><span class="line"><span class="keyword">auto</span>&amp; texture = AssetManager::GetTexture(<span class="string">"myTexture.png"</span>);</span><br><span class="line"></span><br><span class="line">sf::<span class="function">Sprite <span class="title">sprite1</span><span class="params">(texture)</span></span>;</span><br><span class="line">sprite1.setOrigin(spriteSize * <span class="number">0.5f</span>);</span><br><span class="line">sprite1.setPosition(sf::Vector2f(<span class="number">-100</span>, <span class="number">-100</span>));</span><br><span class="line"></span><br><span class="line">sf::<span class="function">Sprite <span class="title">sprite2</span><span class="params">(texture)</span></span>;</span><br><span class="line">sprite2.setOrigin(spriteSize * <span class="number">0.5f</span>);</span><br><span class="line">sprite2.setPosition(sf::Vector2f(<span class="number">100</span>, <span class="number">-100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sf::<span class="function">Sprite <span class="title">sprite3</span><span class="params">(texture)</span></span>;</span><br><span class="line">sprite3.setOrigin(spriteSize * <span class="number">0.5f</span>);</span><br><span class="line">sprite3.setPosition(sf::Vector2f(<span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sf::<span class="function">Sprite <span class="title">sprite4</span><span class="params">(texture)</span></span>;</span><br><span class="line">sprite4.setOrigin(spriteSize * <span class="number">0.5f</span>);</span><br><span class="line">sprite4.setPosition(sf::Vector2f(<span class="number">-100</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure><p>分别旋转 <strong>0 度</strong>和 <strong>45 度</strong>，效果如下</p><p><img alt="http://sshpark.github.io/images/20190909205905.png" width="300px" /></p><p><img alt="http://sshpark.github.io/images/20190909205916.png" width="300px" /></p><p>旋转视图（view）在游戏开发方面的用途有限。 它可以用于制作特定事件的动画 - 主角的死亡（随着旋转的慢速放大），受到伤害（相机略微抖动）。 我们也可以使用它来围绕一个居中的角色在一个自上而下的游戏中旋转世界。 通常，旋转很有用，但是使用场所有限。</p><p>接下来是缩放，缩放的话可以使用 <code>View::zoom()</code>。传入的参数为 2 的话代表缩小 2 倍，传入 0.5 则是放大 2 倍。也可以通过 <code>View::setSize()</code> 改变 view 的大小实现缩放。</p><p>需要注意的是，使用缩放的时候 view 存储的是当前 view 大小，也就是说，如果我们多次调用缩放函数，view 会基于上一次的 view 进行缩放。举个例子，两次使用 <code>zoom(2)</code> 的时候，view 的大小会是 <code>1/2*1/2*size = 1/4*size</code>。</p><p>&lt;/br&gt;</p><h3 id="五、视口（viewport）"><a href="#五、视口（viewport）" class="headerlink" title="五、视口（viewport）"></a>五、视口（viewport）</h3><p>每个视图（view）都有一个与之关联的视口（viewport）。 视口是显示视图的窗口区域。 该区域由矩形表示，该矩形使用标准化坐标<code>[0 ... 1]</code>。 默认情况下，视口等于视图的大小<code>（0,0,1,1）</code>。 我们可以通过调用<code>View::setViewport()</code>来改变它。 假设我们只想在屏幕的左上象限中渲染场景。 可以这么做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wSize = window.getSize();</span><br><span class="line">sf::<span class="function">View <span class="title">view</span><span class="params">(sf::Vector2f(<span class="number">0</span>, <span class="number">0</span>), sf::Vector2f(wSize.x, wSize.y))</span></span>;</span><br><span class="line"></span><br><span class="line">view.setViewport(sf::FloatRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">window.setView(view);</span><br></pre></td></tr></table></figure><p>运行后的结果如下：</p><p><img src="http://sshpark.github.io/images/20190909221627.png" width="450px" /></p><p>&lt;/br&gt;</p><h3 id="六、坐标转换"><a href="#六、坐标转换" class="headerlink" title="六、坐标转换"></a>六、坐标转换</h3><p><code>RenderWindow::mapPixelToCoords()</code> 方法用于将目标坐标转换为世界坐标。一开始的时候，这两个坐标系下的物体坐标是对应的，但是当我们使用自定义 view 或者改变窗口大小的时候，这个对应关系就不存在了，这时候，需要调用这个方法获取物体的世界坐标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sf::Event ev;</span><br><span class="line"><span class="keyword">while</span> (window.pollEvent(ev)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.type == sf::Event::MouseButtonPressed) &#123;</span><br><span class="line">        sf::Vector2f sceneCoords = window.mapPixelToCoords(</span><br><span class="line">        sf::Vector2i(ev.mouseButton.x, ev.mouseButton.y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&lt;/br&gt;</p><h3 id="七、OpenGL"><a href="#七、OpenGL" class="headerlink" title="七、OpenGL"></a>七、OpenGL</h3><p><strong>OpenGL</strong> 是一种跨平台的图形 API，用作与图形卡通信的接口。 任何图形 API 最重要的特性是它能够在屏幕上渲染对象。 虽然 <strong>OpenGL</strong> 确实如此，但是它还有许多其他有用的功能。</p><p>实际上，<strong>SFML</strong> 在内部使用 <strong>OpenGL</strong> 来实现功能。但是，由于 <strong>SFML</strong> 是一个高级库，因此使用它时将会存在性能损失。在大多数情况下，这部分性能并不是一个大问题，因为使用这样一个高级库的好处是它可以快速地开发应用。但是，有些情况只需要额外的性能来实现目标 FPS。在这种情况下，<strong>SFML</strong> 提供了一个简单的 <strong>OpenGL</strong> 代码集成，而不必担心太多事情。</p><p>在我们开始使用任何OpenGL调用之前，我们需要先<strong>初始化图形上下文</strong>。 上下文保存了 <strong>OpenGL</strong> 运行时的数据（状态，默认帧缓冲等）。这在我们创建窗口实例时自动完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SFML/Window.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SFML/OpenGL.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sf::ContextSettings settings;</span><br><span class="line">    settings.depthBits = <span class="number">24</span>;</span><br><span class="line">    settings.stencilBits = <span class="number">8</span>;</span><br><span class="line">    settings.majorVersion = <span class="number">3</span>;</span><br><span class="line">    settings.minorVersion = <span class="number">0</span>;</span><br><span class="line">    settings.antialiasingLevel = <span class="number">2</span>;</span><br><span class="line">    sf::<span class="function">Window <span class="title">window</span><span class="params">(sf::VideoMode(<span class="number">640</span>, <span class="number">480</span>), <span class="string">"OpenGL"</span>, sf::Style::Default, settings)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (window.isOpen()) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用 <strong>OpenGL</strong> 的话，我们需要包含 <strong><SFML/OpenGL.hpp></strong>，这是 <strong>SFML</strong> 为我们在所有平台上使用提供的通用头文件。 同样重要的是，如果我们要仅使用OpenGL渲染所有东西，我们就不需要使用熟悉的RenderWindow类。 Window类很适合我们。另一方面，如果出于某种原因我们想要将 <strong>OpenGL</strong> 与 <strong>Graphics 模块</strong>一起使用，那么我们可以回到 <strong>RenderWindow</strong>。 在这个例子中，我们只使用 <strong>Window模块</strong>。</p><p>窗口采用ContextSettings的实例（可选参数）具有一下参数</p><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th><th>范围</th></tr></thead><tbody><tr><td>depthBits</td><td>深度缓冲器的每像素位数</td><td>[0, 8, 16, 24, 32]</td></tr><tr><td>stencilBits</td><td>模板缓冲区的每像素位数</td><td>[0, 8]</td></tr><tr><td>majorVersion</td><td>OpenGL的主要版本</td><td>[1 … 4]</td></tr><tr><td>minorVersion</td><td>OpenGL的次要版本</td><td>[1 … 5]</td></tr><tr><td>antialiasingLevel</td><td>多重采样级别</td><td>[0 … 16]，通常使用 2 的幂次</td></tr></tbody></table></div><p><strong>SFML</strong> 并不强制我们一定要使用上面的参数，它有默认值。</p><p>当一切都准备好了以后，可以开始写主循环部分的代码了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (window.isOpen()) &#123;</span><br><span class="line">    sf::Event ev;</span><br><span class="line">    <span class="keyword">while</span> (window.pollEvent(ev)) &#123;</span><br><span class="line">        <span class="comment">// 更新帧</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置清除色</span></span><br><span class="line">        glClearColor(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 清除屏幕和深度缓冲区</span></span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制物体</span></span><br><span class="line">        window.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <strong>SFML</strong> 窗口是为使用 <strong>OpenGL</strong> 而构建的，因此集成它就像前面的代码一样简单。 但是，当涉及到混合<strong>Graphics模块</strong>和 <strong>OpenGL</strong> 时，它会变得稍微混乱。 每次我们在使用 <strong>SFML</strong> 进行渲染和使用 <strong>OpenGL</strong> 进行渲染时，我们都必须<strong>保存和恢复</strong> <strong>OpenGL</strong> 状态。 这是使用<strong>Graphics模块</strong>和 <strong>OpenGL</strong> 绘制形状时的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 OpenGL 绘制对象</span></span><br><span class="line"></span><br><span class="line">window.pushGLStates();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 SFML 绘制对象</span></span><br><span class="line"></span><br><span class="line">window.popGLStates();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续使用 OpenGL 绘制</span></span><br><span class="line"></span><br><span class="line">window.display();</span><br></pre></td></tr></table></figure><p>SFML允许我们在每个应用程序中使用多个窗口。 游戏拥有多窗口是非常罕见的，但是媒体应用程序是这样的。当我们想要在特定窗口中渲染对象时，我们调用<code>RenderWindow::draw()</code>。 但是，当我们想要使用 <strong>OpenGL</strong> 时，我们需要<strong>指定哪个窗口</strong>受需要用到 <strong>OpenGL</strong>，这只是由<code>Window::setActive()</code>完成的。当我们想要在窗口上开始渲染时，我们只需调用<code>setActive()</code>并开始使用 <strong>OpenGL</strong>。</p><p>到这里我们的 <strong>OpenGL</strong> 部分就结束了。</p><p>在下一篇文章中，我们将探讨游戏中的声音，音乐和文本的三个概念上简单但却至关重要的特性😃。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将会介绍怎么在程序中使用摄像机和 &lt;strong&gt;OpenGL&lt;/strong&gt; 。对摄像机将会深入的介绍，而对于 &lt;strong&gt;OpenGL&lt;/strong&gt;，我们这里只做简单的介绍。&lt;strong&gt;OpenGL&lt;/strong&gt; 是一个很大的主题，一篇文章根本就不能够将它完全介绍清楚。&lt;/p&gt;
&lt;p&gt;本文将会介绍以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是摄像机&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;sf::View&lt;/code&gt; 操作摄像机&lt;/li&gt;
&lt;li&gt;什么是 &lt;strong&gt;OpenGL&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;strong&gt;SFML&lt;/strong&gt; 中使用 &lt;strong&gt;OpenGL&lt;/strong&gt;
    
    </summary>
    
    
    
      <category term="SFML" scheme="http://sshpark.com.cn/tags/SFML/"/>
    
      <category term="用C++和SFML写游戏" scheme="http://sshpark.com.cn/tags/%E7%94%A8C-%E5%92%8CSFML%E5%86%99%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
</feed>
